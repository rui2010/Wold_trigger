<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ワールドトリガー 市街地Aテスト</title>
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #fff; font-size: 16px;
      background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 6px;
      z-index: 10;
    }
    #leftTriggerUI, #rightTriggerUI {
      position: fixed;
      bottom: 20px;
      width: 220px;
      height: 80px;
      background: rgba(40,40,60,0.5);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: space-around;
      z-index: 20;
      pointer-events: none;
    }
    #leftTriggerUI { left: 20px; }
    #rightTriggerUI { right: 20px; flex-direction: row-reverse; }
    .trigger-slot {
      width: 44px; height: 44px;
      background: rgba(180,180,200,0.18);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      margin: 0 2px;
      font-size: 0.9em;
      color: #fff;
      border: 2px solid transparent;
      transition: border 0.2s;
    }
    .trigger-selected {
      border: 2px solid #66ccff;
      background: rgba(80,160,255,0.25);
    }
  </style>
</head>
<body>
  <div id="info">
    WASD:移動 / Shift:しゃがみ / Space:ジャンプ / Ctrl+W:走り<br>
    左クリック:左手トリガー / 右クリック:右手トリガー<br>
    Q:左トリガー変更 / E:右トリガー変更 / F:左特殊 / G:右特殊
  </div>
  <div id="leftTriggerUI"></div>
  <div id="rightTriggerUI"></div>
  <canvas id="gameCanvas"></canvas>
  <script>
    // --- THREE.jsセットアップ ---
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x222222);
    function resizeRenderer() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, true);
      canvas.width = w; canvas.height = h;
    }
    resizeRenderer();
    window.addEventListener('resize', resizeRenderer);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    // --- 市街地Aマップ ---
    // 7x7グリッド、中央広場、道路、建物
    const mapSize = 7, blockSize = 8, roadWidth = 2;
    // 建物の高さ・色・屋根形状をアニメ風に
    const buildingTypes = [
      // 白壁＋青屋根
      { color: 0xf8f8f8, roof: 0x3366cc, height: 8, roofHeight: 2.2 },
      // ベージュ壁＋赤屋根
      { color: 0xf6e3b4, roof: 0xcc3333, height: 10, roofHeight: 2.5 },
      // 灰色壁＋緑屋根
      { color: 0xd0d0d0, roof: 0x339966, height: 12, roofHeight: 2.8 },
      // 薄茶壁＋茶屋根
      { color: 0xeed9c4, roof: 0x996633, height: 9, roofHeight: 2.0 }
    ];
    for (let gx = 0; gx < mapSize; gx++) {
      for (let gz = 0; gz < mapSize; gz++) {
        if (gx >= 2 && gx <= 4 && gz >= 2 && gz <= 4) continue;
        if (gx === 3 || gz === 3 || gx === 2 || gx === 4 || gz === 2 || gz === 4) continue;
        if (Math.random() < 0.13) continue;
        // アニメ風の家タイプをランダム選択
        const t = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
        // 本体（壁）
        const house = new THREE.Mesh(
          new THREE.BoxGeometry(blockSize, t.height, blockSize),
          new THREE.MeshPhongMaterial({ color: t.color, emissive: 0x222222, emissiveIntensity: 0.18 })
        );
        house.position.set((gx - 3) * (blockSize + 2), t.height / 2, (gz - 3) * (blockSize + 2));
        scene.add(house);
        // 屋根（アニメ風の三角屋根）
        const roof = new THREE.Mesh(
          new THREE.ConeGeometry(blockSize * 0.95, t.roofHeight, 4),
          new THREE.MeshPhongMaterial({ color: t.roof, shininess: 60 })
        );
        roof.position.set(house.position.x, t.height + t.roofHeight / 2, house.position.z);
        roof.rotation.y = Math.PI / 4;
        scene.add(roof);
        // 窓（白い四角を壁に貼る）
        for (let wx = -1; wx <= 1; wx += 2) {
          const window = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 1.2, 0.18),
            new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xeeeeee, emissiveIntensity: 0.5 })
          );
          window.position.set(house.position.x + wx * 2.2, house.position.y + 1.2, house.position.z + blockSize / 2 + 0.1);
          scene.add(window);
        }
        // ドア（茶色い四角）
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(1.1, 2.0, 0.18),
          new THREE.MeshPhongMaterial({ color: 0x996633 })
        );
        door.position.set(house.position.x, house.position.y - t.height / 2 + 1.0, house.position.z + blockSize / 2 + 0.11);
        scene.add(door);
      }
    }
    // 地面
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshPhongMaterial({ color: 0x66cc66 })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);
    // 道路
    const roadMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
    for (let gx = 2; gx <= 4; gx++) {
      const road = new THREE.Mesh(
        new THREE.BoxGeometry(roadWidth, 0.11, mapSize * (blockSize + 2)),
        roadMat
      );
      road.position.set((gx - 3) * (blockSize + 2), 0.06, 0);
      scene.add(road);
    }
    for (let gz = 2; gz <= 4; gz++) {
      const road = new THREE.Mesh(
        new THREE.BoxGeometry(mapSize * (blockSize + 2), 0.11, roadWidth),
        roadMat
      );
      road.position.set(0, 0.06, (gz - 3) * (blockSize + 2));
      scene.add(road);
    }
    // 広場
    const plaza = new THREE.Mesh(
      new THREE.BoxGeometry((roadWidth + 1) * (blockSize + 2), 0.12, (roadWidth + 1) * (blockSize + 2)),
      new THREE.MeshPhongMaterial({ color: 0xddddcc })
    );
    plaza.position.set(0, 0.07, 0);
    scene.add(plaza);

    // --- ライト ---
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    // --- プレイヤー ---
    let playerPos = new THREE.Vector3(0, 2, 0);
    let playerVel = new THREE.Vector3(0, 0, 0);
    let isOnGround = false, isCrouching = false, isRunning = false;
    let yaw = 0, pitch = 0;
    let standHeight = 3.8, crouchHeight = 2.0, playerHeight = standHeight;

    // --- プレイヤーモデル追加（アニメ風・空閑遊真カラーリング重視のシンプルモデル） ---
    // 既存のyumaGroup生成部分を以下で置き換え

    const yumaGroup = new THREE.Group();

    // 頭（白球）
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.7, 48, 48),
      new THREE.MeshPhysicalMaterial({
        color: 0xf8f8f8,
        roughness: 0.25,
        metalness: 0.1,
        clearcoat: 0.7,
        clearcoatRoughness: 0.1
      })
    );
    head.position.y = 2.7;
    yumaGroup.add(head);

    // 前髪（アニメ風に前方に大きめの毛束を配置）
    for (let i = 0; i < 5; i++) {
      const bang = new THREE.Mesh(
        new THREE.CylinderGeometry(0.09, 0.04, 0.45, 16),
        new THREE.MeshPhysicalMaterial({
          color: 0xf8f8f8,
          roughness: 0.18,
          metalness: 0.18,
          clearcoat: 1,
          clearcoatRoughness: 0.04
        })
      );
      bang.position.y = 3.1 + (Math.random() - 0.5) * 0.04;
      bang.position.x = (i - 2) * 0.13 + (Math.random() - 0.5) * 0.03;
      bang.position.z = 0.7 + (Math.random() - 0.5) * 0.03;
      bang.rotation.x = Math.PI / 2.1 + (Math.random() - 0.5) * 0.1;
      yumaGroup.add(bang);
    }
    // サイド・後頭部の髪
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      const hair = new THREE.Mesh(
        new THREE.CylinderGeometry(0.07, 0.03, 0.38 + Math.random() * 0.08, 12),
        new THREE.MeshPhysicalMaterial({
          color: 0xf8f8f8,
          roughness: 0.18,
          metalness: 0.18,
          clearcoat: 1,
          clearcoatRoughness: 0.04
        })
      );
      hair.position.y = 3.05 + (Math.random() - 0.5) * 0.04;
      hair.position.x = Math.cos(angle) * 0.45 + (Math.random() - 0.5) * 0.03;
      hair.position.z = Math.sin(angle) * 0.45 + (Math.random() - 0.5) * 0.03;
      hair.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.2;
      hair.rotation.z = angle;
      yumaGroup.add(hair);
    }

    // 顔（目・口：アニメ風にシンプルな配置）
    function createAnimeEye(x) {
      const eyeGroup = new THREE.Group();
      // 白目
      const eyeWhite = new THREE.Mesh(
        new THREE.SphereGeometry(0.13, 24, 24),
        new THREE.MeshPhongMaterial({ color: 0xffffff })
      );
      eyeWhite.position.set(x, 2.85, 0.62);
      eyeGroup.add(eyeWhite);
      // 黒目
      const eyeBlack = new THREE.Mesh(
        new THREE.SphereGeometry(0.07, 24, 24),
        new THREE.MeshPhongMaterial({ color: 0x222222 })
      );
      eyeBlack.position.set(x, 2.85, 0.7);
      eyeGroup.add(eyeBlack);
      // 赤い瞳孔
      const eyeRed = new THREE.Mesh(
        new THREE.SphereGeometry(0.03, 16, 16),
        new THREE.MeshPhongMaterial({ color: 0xff4444 })
      );
      eyeRed.position.set(x, 2.85, 0.74);
      eyeGroup.add(eyeRed);
      return eyeGroup;
    }
    yumaGroup.add(createAnimeEye(0.22));
    yumaGroup.add(createAnimeEye(-0.22));

    // 口（アニメ風の細いピンクの円弧）
    const mouthShape = new THREE.TorusGeometry(0.09, 0.01, 8, 32, Math.PI * 0.7);
    const mouth = new THREE.Mesh(
      mouthShape,
      new THREE.MeshPhongMaterial({ color: 0xffb0b0, shininess: 60 })
    );
    mouth.position.set(0, 2.67, 0.73);
    mouth.rotation.x = Math.PI / 2.1;
    yumaGroup.add(mouth);

    // 胴体（青＋白ライン＋肩の白パーツ、アニメのB級玉狛服カラー）
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(0.9, 1.3, 0.6),
      new THREE.MeshPhysicalMaterial({
        color: 0x2277cc,
        roughness: 0.18,
        metalness: 0.15,
        clearcoat: 0.7
      })
    );
    body.position.y = 1.5;
    yumaGroup.add(body);
    // 白ライン（前面縦ライン）
    const line = new THREE.Mesh(
      new THREE.BoxGeometry(0.13, 1.1, 0.62),
      new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.08, metalness: 0.03 })
    );
    line.position.set(0, 1.5, 0.01);
    yumaGroup.add(line);
    // 肩（白い半球パーツ）
    for (let i = -1; i <= 1; i += 2) {
      const shoulder = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.08, metalness: 0.03 })
      );
      shoulder.position.set(0.62 * i, 2.1, 0);
      shoulder.rotation.x = -Math.PI / 2;
      yumaGroup.add(shoulder);
    }

    // --- 腕 ---
    function createAnimeArm(isLeft) {
      const arm = new THREE.Group();
      // 上腕
      const upper = new THREE.Mesh(
        new THREE.CylinderGeometry(0.14, 0.16, 0.6, 16),
        new THREE.MeshPhysicalMaterial({ color: 0x2277cc, roughness: 0.18, metalness: 0.15 })
      );
      upper.position.y = 0.3;
      arm.add(upper);
      // 白ライン
      const stripe = new THREE.Mesh(
        new THREE.BoxGeometry(0.05, 0.5, 0.13),
        new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.08, metalness: 0.03 })
      );
      stripe.position.set(0, 0.3, 0.11);
      arm.add(stripe);
      // 前腕
      const lower = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.13, 0.5, 16),
        new THREE.MeshPhysicalMaterial({ color: 0x2277cc, roughness: 0.18, metalness: 0.15 })
      );
      lower.position.y = -0.25;
      lower.position.z = 0.01;
      lower.rotation.x = Math.PI / 16 * (isLeft ? 1 : -1);
      arm.add(lower);
      // 手（肌色球）
      const hand = new THREE.Mesh(
        new THREE.SphereGeometry(0.13, 16, 16),
        new THREE.MeshPhysicalMaterial({ color: 0xffe0c0, roughness: 0.25, metalness: 0.08 })
      );
      hand.position.y = -0.55;
      hand.position.z = 0.01;
      arm.add(hand);
      arm.position.set(isLeft ? -0.65 : 0.65, 1.7, 0);
      arm.rotation.z = isLeft ? Math.PI / 8 : -Math.PI / 8;
      return arm;
    }
    yumaGroup.add(createAnimeArm(true));
    yumaGroup.add(createAnimeArm(false));

    // --- 脚 ---
    function createAnimeLeg(isLeft) {
      const leg = new THREE.Group();
      // 太もも
      const thigh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.13, 0.15, 0.6, 16),
        new THREE.MeshPhysicalMaterial({ color: 0x2277cc, roughness: 0.18, metalness: 0.15 })
      );
      thigh.position.y = 0.3;
      leg.add(thigh);
      // 白ライン
      const stripe = new THREE.Mesh(
        new THREE.BoxGeometry(0.04, 0.5, 0.13),
        new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.08, metalness: 0.03 })
      );
      stripe.position.set(0, 0.3, 0.09);
      leg.add(stripe);
      // すね
      const shin = new THREE.Mesh(
        new THREE.CylinderGeometry(0.11, 0.12, 0.6, 16),
        new THREE.MeshPhysicalMaterial({ color: 0x2277cc, roughness: 0.18, metalness: 0.15 })
      );
      shin.position.y = -0.25;
      shin.position.z = 0.01;
      shin.rotation.x = Math.PI / 32 * (isLeft ? 1 : -1);
      leg.add(shin);
      // 靴（黒球＋つま先）
      const shoe = new THREE.Mesh(
        new THREE.SphereGeometry(0.13, 16, 16),
        new THREE.MeshPhysicalMaterial({ color: 0x222222, roughness: 0.18, metalness: 0.18 })
      );
      shoe.position.y = -0.55;
      shoe.position.z = 0.01;
      leg.add(shoe);
      // つま先（黒い半球）
      const toe = new THREE.Mesh(
        new THREE.SphereGeometry(0.09, 12, 12, 0, Math.PI),
        new THREE.MeshPhysicalMaterial({ color: 0x222222, roughness: 0.18, metalness: 0.18 })
      );
      toe.position.y = -0.62;
      toe.position.z = 0.11;
      toe.rotation.x = Math.PI / 2;
      leg.add(toe);

      leg.position.set(isLeft ? -0.28 : 0.28, 0.2, 0);
      return leg;
    }
    yumaGroup.add(createAnimeLeg(true));
    yumaGroup.add(createAnimeLeg(false));

    scene.add(yumaGroup);

    // --- TPS視点用カメラオフセット ---
    // ここを新しいカメラ位置に変更（例: もっと高く遠くから見下ろす）
    // 例: 少し右上・遠め・高め
    const cameraOffset = new THREE.Vector3(1.5, 5.5, -10);

    // --- マウス移動 ---
    // TPS視点のため、マウス移動でプレイヤーの向きを変更（上下視点も有効化）
    canvas.addEventListener('click', () => { canvas.requestPointerLock(); });
    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === canvas) {
        document.addEventListener('mousemove', onMouseMove, false);
      } else {
        document.removeEventListener('mousemove', onMouseMove, false);
      }
    });
    function onMouseMove(e) {
      const sensitivity = 0.002;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch)); // 上下制限
    }

    // --- 玉トリガー分割制御 ---
    let leftBulletSplit = false, rightBulletSplit = false;

    // --- トリガー（武器）モデル ---
    function createTriggerModel(type, split = false) {
      // 玉トリガー（アステロイド・ハウンド・バイパー・メテオラ）は正方形＋蛍光白＋緑縁
      if (
        type === "asteroid" ||
        type === "hound" ||
        type === "viper" ||
        type === "meteorora"
      ) {
        // 必ず正方形
        if (!split) {
          // 通常：正方形＋蛍光白＋緑縁
          const group = new THREE.Group();
          const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5),
            new THREE.MeshPhysicalMaterial({
              color: 0xffffff,
              emissive: 0xffffff,
              emissiveIntensity: 1.2,
              roughness: 0.1,
              metalness: 0.3,
              transmission: 0.7,
              transparent: true,
              opacity: 0.95,
              clearcoat: 0.8,
              clearcoatRoughness: 0.05
            })
          );
          group.add(box);
          // 緑色の縁（ワイヤーフレーム）
          const edge = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.BoxGeometry(0.52, 0.52, 0.52)),
            new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })
          );
          group.add(edge);
          return group;
        } else {
          // 分割：2x2x2=8個の小さい正方形玉
          const group = new THREE.Group();
          const positions = [-0.18, 0.18];
          for (let x of positions) {
            for (let y of positions) {
              for (let z of positions) {
                const small = new THREE.Mesh(
                  new THREE.BoxGeometry(0.18, 0.18, 0.18),
                  new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 1.2,
                    roughness: 0.1,
                    metalness: 0.3,
                    transmission: 0.7,
                    transparent: true,
                    opacity: 0.95,
                    clearcoat: 0.8,
                    clearcoatRoughness: 0.05
                  })
                );
                small.position.set(x, y, z);
                group.add(small);
                // 緑色の縁
                const edge = new THREE.LineSegments(
                  new THREE.EdgesGeometry(new THREE.BoxGeometry(0.2, 0.2, 0.2)),
                  new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })
                );
                edge.position.copy(small.position);
                group.add(edge);
              }
            }
          }
          return group;
        }
      }
      if (type === "shield") {
        // シールド：漫画風の六角形バリア（透明感＋エッジ＋縁取り）
        const group = new THREE.Group();
        const shield = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 0.08, 6),
          new THREE.MeshPhysicalMaterial({
            color: 0x99ccff,
            roughness: 0.08,
            metalness: 0.1,
            transmission: 0.95,
            transparent: true,
            opacity: 0.45,
            clearcoat: 0.9,
            clearcoatRoughness: 0.03,
            ior: 1.5
          })
        );
        shield.rotation.x = Math.PI / 2;
        group.add(shield);
        // 縁取り
        const edge = new THREE.Mesh(
          new THREE.TorusGeometry(0.5, 0.015, 8, 32),
          new THREE.MeshPhongMaterial({ color: 0x66ccff })
        );
        edge.rotation.x = Math.PI / 2;
        group.add(edge);
        return group;
      }
      if (type === "kogetsu") {
        // 弧月：湾曲した刀（銀色の刃＋黒い柄＋鍔）
        const group = new THREE.Group();
        // 刃（湾曲）
        const bladeCurve = new THREE.TorusGeometry(0.38, 0.04, 16, 48, Math.PI * 0.7);
        const bladeMat = new THREE.MeshPhysicalMaterial({
          color: 0xe0e0e0,
          metalness: 0.85,
          roughness: 0.18,
          clearcoat: 0.8
        });
        const blade = new THREE.Mesh(bladeCurve, bladeMat);
        blade.rotation.z = Math.PI / 2;
        blade.position.y = 0.35;
        group.add(blade);
        // 柄
        const grip = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.22, 12),
          new THREE.MeshPhongMaterial({ color: 0x222222 })
        );
        grip.position.y = -0.25;
        group.add(grip);
        // 鍔
        const tsuba = new THREE.Mesh(
          new THREE.TorusGeometry(0.07, 0.012, 8, 24),
          new THREE.MeshPhongMaterial({ color: 0x888888 })
        );
        tsuba.position.y = 0.05;
        group.add(tsuba);
        return group;
      }
      if (type === "senku") {
        // 千空：弧月＋大きな青いエフェクト（漫画風）
        const group = new THREE.Group();
        // 刃（湾曲）
        const bladeCurve = new THREE.TorusGeometry(0.38, 0.04, 16, 48, Math.PI * 0.7);
        const bladeMat = new THREE.MeshPhysicalMaterial({
          color: 0xe0e0e0,
          metalness: 0.85,
          roughness: 0.18,
          clearcoat: 0.8
        });
        const blade = new THREE.Mesh(bladeCurve, bladeMat);
        blade.rotation.z = Math.PI / 2;
        blade.position.y = 0.35;
        group.add(blade);
        // 柄
        const grip = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.22, 12),
          new THREE.MeshPhongMaterial({ color: 0x222222 })
        );
        grip.position.y = -0.25;
        group.add(grip);
        // 鍔
        const tsuba = new THREE.Mesh(
          new THREE.TorusGeometry(0.07, 0.012, 8, 24),
          new THREE.MeshPhongMaterial({ color: 0x888888 })
        );
        tsuba.position.y = 0.05;
        group.add(tsuba);
        // 千空エフェクト
        const effect = new THREE.Mesh(
          new THREE.TorusGeometry(0.65, 0.025, 8, 48, Math.PI * 1.2),
          new THREE.MeshPhysicalMaterial({
            color: 0x3399ff,
            transparent: true,
            opacity: 0.5,
            transmission: 0.9,
            roughness: 0.08,
            metalness: 0.2
          })
        );
        effect.position.y = 0.45;
        effect.rotation.z = Math.PI / 2;
        group.add(effect);
        return group;
      }
      // デフォルト
      return new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshPhongMaterial({ color: 0x999999 }));
    }

    // --- トリガーセット ---
    const TRIGGERS = ["asteroid", "hound", "viper", "meteorora", "shield", "kogetsu", "senku"];
    let leftTriggerSet = ["asteroid", "hound", "viper", "meteorora"];
    let rightTriggerSet = ["shield", "kogetsu", "senku", "asteroid"];
    let leftTriggerIndex = 0, rightTriggerIndex = 0;
    let leftTriggerType = leftTriggerSet[leftTriggerIndex], rightTriggerType = rightTriggerSet[rightTriggerIndex];

    // --- トリガーUI描画 ---
    function updateTriggerUI() {
      const leftUI = document.getElementById('leftTriggerUI');
      const rightUI = document.getElementById('rightTriggerUI');
      leftUI.innerHTML = '';
      rightUI.innerHTML = '';
      for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.className = 'trigger-slot' + (i === leftTriggerIndex ? ' trigger-selected' : '');
        slot.textContent = getTriggerName(leftTriggerSet[i]);
        leftUI.appendChild(slot);
      }
      for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.className = 'trigger-slot' + (i === rightTriggerIndex ? ' trigger-selected' : '');
        slot.textContent = getTriggerName(rightTriggerSet[i]);
        rightUI.appendChild(slot);
      }
    }
    function getTriggerName(type) {
      switch(type) {
        case "asteroid": return "アステロイド";
        case "hound": return "ハウンド";
        case "viper": return "バイパー";
        case "meteorora": return "メテオラ";
        case "shield": return "シールド";
        case "kogetsu": return "弧月";
        case "senku": return "旋空弧月";
        default: return type;
      }
    }
    updateTriggerUI();

    // --- 入力 ---
    const move = { forward: false, backward: false, left: false, right: false };
    let jumpRequested = false;
    window.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') move.forward = true;
      if (e.code === 'KeyS') move.backward = true;
      if (e.code === 'KeyA') move.left = true;
      if (e.code === 'KeyD') move.right = true;
      if (e.code === 'Space') jumpRequested = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = true;
      if (e.code === 'ControlLeft' || e.code === 'ControlRight') isRunning = true;
      if (e.code === 'KeyQ') {
        // 左トリガー切り替え時に表示中のトリガーを消す
        if (leftBulletObj) { scene.remove(leftBulletObj); leftBulletObj = null; leftBulletReady = false; }
        if (leftTriggerObj) { scene.remove(leftTriggerObj); leftTriggerObj = null; }
        leftTriggerIndex = (leftTriggerIndex + 1) % leftTriggerSet.length;
        leftTriggerType = leftTriggerSet[leftTriggerIndex];
        updateTriggerUI();
      }
      if (e.code === 'KeyE') {
        // 右トリガー切り替え時に表示中のトリガーを消す
        if (rightBulletObj) { scene.remove(rightBulletObj); rightBulletObj = null; rightBulletReady = false; }
        if (rightTriggerObj) { scene.remove(rightTriggerObj); rightTriggerObj = null; }
        rightTriggerIndex = (rightTriggerIndex + 1) % rightTriggerSet.length;
        rightTriggerType = rightTriggerSet[rightTriggerIndex];
        updateTriggerUI();
      }
      // F:左特殊, G:右特殊（弧月起動）
      if (e.code === 'KeyF') {
        if (["asteroid", "hound", "viper", "meteorora"].includes(leftTriggerType)) {
          leftBulletSplit = !leftBulletSplit;
          // 表示中なら分割状態を切り替え
          if (leftBulletObj) {
            scene.remove(leftBulletObj);
            leftBulletObj = createTriggerModel(leftTriggerType, leftBulletSplit);
            scene.add(leftBulletObj);
          }
        } else if (leftTriggerType === "kogetsu") {
          kogetsuActiveLeft = !kogetsuActiveLeft;
          if (!kogetsuActiveLeft && leftTriggerObj) {
            scene.remove(leftTriggerObj);
            leftTriggerObj = null;
          }
        } else {
          leftSpecialActive = !leftSpecialActive;
        }
      }
      if (e.code === 'KeyG') {
        if (["asteroid", "hound", "viper", "meteorora"].includes(rightTriggerType)) {
          rightBulletSplit = !rightBulletSplit;
          if (rightBulletObj) {
            scene.remove(rightBulletObj);
            rightBulletObj = createTriggerModel(rightTriggerType, rightBulletSplit);
            scene.add(rightBulletObj);
          }
        } else if (rightTriggerType === "kogetsu") {
          kogetsuActiveRight = !kogetsuActiveRight;
          if (!kogetsuActiveRight && rightTriggerObj) {
            scene.remove(rightTriggerObj);
            rightTriggerObj = null;
          }
        } else {
          rightSpecialActive = !rightSpecialActive;
        }
      }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') move.forward = false;
      if (e.code === 'KeyS') move.backward = false;
      if (e.code === 'KeyA') move.left = false;
      if (e.code === 'KeyD') move.right = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = false;
      if (e.code === 'ControlLeft' || e.code === 'ControlRight') isRunning = false;
    });

    // --- ジャンプ ---
    let wantJump = false;

    // --- 弾丸管理 ---
    let bullets = [];

    // --- 玉トリガー発射制御 ---
    let leftBulletReady = false, rightBulletReady = false;
    let leftBulletObj = null, rightBulletObj = null;

    // --- トリガー発動 ---
    let leftTriggerObj = null, rightTriggerObj = null;
    let leftSpecialActive = false, rightSpecialActive = false;
    // --- 弧月攻撃制御 ---
    let kogetsuActiveLeft = false, kogetsuActiveRight = false;
    let kogetsuAttackLeft = false, kogetsuAttackRight = false;
    canvas.addEventListener('mousedown', (e) => {
      // 玉トリガーは2回クリックで発射
      if (e.button === 0) {
        if (["asteroid", "hound", "viper", "meteorora"].includes(leftTriggerType)) {
          if (!leftBulletReady) {
            // 1回目クリック：必ず分割なしで表示
            leftBulletObj = createTriggerModel(leftTriggerType, false);
            scene.add(leftBulletObj);
            leftBulletReady = true;
            leftBulletSplit = false; // 分割状態を解除
          } else {
            // 2回目クリック：発射
            fireBullet(leftTriggerType, "left", leftBulletObj, leftBulletSplit);
            leftBulletObj = null;
            leftBulletReady = false;
          }
        } else if (leftTriggerType === "kogetsu") {
          kogetsuActiveLeft = !kogetsuActiveLeft;
          if (!kogetsuActiveLeft && leftTriggerObj) {
            scene.remove(leftTriggerObj);
            leftTriggerObj = null;
          }
        } else if (leftTriggerType === "shield") {
          if (!leftTriggerObj) {
            leftTriggerObj = createTriggerModel(leftTriggerType);
            scene.add(leftTriggerObj);
          } else {
            scene.remove(leftTriggerObj);
            leftTriggerObj = null;
          }
        }
      }
      if (e.button === 2) {
        if (["asteroid", "hound", "viper", "meteorora"].includes(rightTriggerType)) {
          if (!rightBulletReady) {
            // 1回目クリック：必ず分割なしで表示
            rightBulletObj = createTriggerModel(rightTriggerType, false);
            scene.add(rightBulletObj);
            rightBulletReady = true;
            rightBulletSplit = false; // 分割状態を解除
          } else {
            // 2回目クリック：発射
            fireBullet(rightTriggerType, "right", rightBulletObj, rightBulletSplit);
            rightBulletObj = null;
            rightBulletReady = false;
          }
        } else if (rightTriggerType === "kogetsu") {
          kogetsuActiveRight = !kogetsuActiveRight;
          if (!kogetsuActiveRight && rightTriggerObj) {
            scene.remove(rightTriggerObj);
            rightTriggerObj = null;
          }
        } else if (rightTriggerType === "shield") {
          if (!rightTriggerObj) {
            rightTriggerObj = createTriggerModel(rightTriggerType);
            scene.add(rightTriggerObj);
          } else {
            scene.remove(rightTriggerObj);
            rightTriggerObj = null;
          }
        }
      }
    });

    // --- 玉トリガー発射 ---
    function fireBullet(triggerType, hand, obj, split = false) {
      if (!obj) return;
      // 発射方向
      const dir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ")).normalize();
      // 発射位置（手元）
      let offset = hand === "left"
        ? new THREE.Vector3(-0.8, -1.2, -1.5).applyEuler(camera.rotation)
        : new THREE.Vector3(0.8, -1.2, -1.5).applyEuler(camera.rotation);
      // 分割時は8個発射（Box+Edgeが交互なので偶数indexのみBox, 0,2,4,6,8,10,12,14）
      if (split && obj.children.length >= 16) {
        for (let i = 0; i < obj.children.length; i += 2) {
          const mesh = obj.children[i].clone();
          scene.add(mesh);
          mesh.position.copy(camera.position).add(offset).add(obj.children[i].position);
          mesh.rotation.copy(camera.rotation);
          // 方向を少しずつずらす（分割玉は中心からの方向ベクトルを加算）
          const spread = obj.children[i].position.clone().multiplyScalar(0.7);
          const velocity = dir.clone().add(spread).normalize().multiplyScalar(0.7);
          bullets.push({
            mesh: mesh,
            velocity: velocity,
            alive: true,
            type: triggerType,
            split: true
          });
        }
        // 分割玉は表示用のobjは消す
        scene.remove(obj);
      } else {
        obj.position.copy(camera.position).add(offset);
        obj.rotation.copy(camera.rotation);
        let speed = 0.7;
        bullets.push({
          mesh: obj,
          velocity: dir.multiplyScalar(speed),
          alive: true,
          type: triggerType,
          split: false
        });
      }
      // 発射後もsceneからは消さない（弾丸管理で消える）
    }

    // --- メテオラ爆発管理 ---
    let explosions = [];

    // --- ゲームループ ---
    function animate() {
      requestAnimationFrame(animate);

      // 移動速度
      let speed = isRunning ? 0.22 : 0.13;
      if (isCrouching) {
        playerHeight = crouchHeight;
      } else {
        playerHeight = standHeight;
      }

      // 移動
      let direction = new THREE.Vector3();
      // Wで前進, Sで後退（修正）
      if (move.forward) direction.z += 1; // Wで前進
      if (move.backward) direction.z -= 1; // Sで後退
      if (move.left) direction.x -= 1;    // Aで左
      if (move.right) direction.x += 1;   // Dで右
      direction.normalize();
      let moveVector = new THREE.Vector3();
      if (direction.length() > 0) {
        // カメラの向きに合わせて移動
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
        const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
        moveVector = forward.multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)).normalize();
      }
      playerVel.x = moveVector.x * speed;
      playerVel.z = moveVector.z * speed;

      // ジャンプ（スペースキーでジャンプ）
      if (jumpRequested && isOnGround) {
        playerVel.y = 0.18;
        isOnGround = false;
      }
      jumpRequested = false;

      // 重力
      playerVel.y += -0.45 * 0.5;

      // 位置更新
      playerPos.add(playerVel);

      // 地面判定
      if (playerPos.y < 1.0) {
        playerPos.y = 1.0;
        playerVel.y = 0;
        isOnGround = true;
      } else {
        isOnGround = false;
      }

      // プレイヤーモデルの位置・向き更新（空閑遊真モデル）
      yumaGroup.position.copy(playerPos);
      yumaGroup.rotation.y = yaw;

      // TPSカメラ位置計算（pitchも反映）
      const camDir = new THREE.Vector3(0, 0, -1)
        .applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
      const camUp = new THREE.Vector3(0, 1, 0);
      const camRight = new THREE.Vector3(1, 0, 0)
        .applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
      // 新しいカメラオフセットを反映
      let camPos = playerPos.clone()
        .add(camUp.clone().multiplyScalar(cameraOffset.y))
        .add(camDir.clone().multiplyScalar(cameraOffset.z))
        .add(camRight.clone().multiplyScalar(cameraOffset.x));
      camera.position.copy(camPos);
      camera.lookAt(playerPos.clone().add(camUp.clone().multiplyScalar(1.2)));

      // トリガーの手元表示（TPSではプレイヤーの前方に表示）
      if (leftBulletObj) {
        leftBulletObj.position.copy(playerPos)
          .add(new THREE.Vector3(-0.8, 1.2, -1.5).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
        leftBulletObj.rotation.y = yaw;
      }
      if (rightBulletObj) {
        rightBulletObj.position.copy(playerPos)
          .add(new THREE.Vector3(0.8, 1.2, -1.5).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
        rightBulletObj.rotation.y = yaw;
      }
      // 弧月・シールド
      if (leftTriggerObj) {
        if (leftTriggerType === "shield") {
          leftTriggerObj.position.copy(playerPos)
            .add(new THREE.Vector3(0, 1.2, -1.1).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
          leftTriggerObj.rotation.y = yaw;
        } else {
          leftTriggerObj.position.copy(playerPos)
            .add(new THREE.Vector3(-0.8, 1.2, -1.5).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
          leftTriggerObj.rotation.y = yaw;
        }
        if (leftTriggerType === "senku" && leftSpecialActive) {
          leftTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = true;
          });
        } else if (leftTriggerType === "senku") {
          leftTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = false;
          });
        }
      }
      if (rightTriggerObj) {
        if (rightTriggerType === "shield") {
          rightTriggerObj.position.copy(playerPos)
            .add(new THREE.Vector3(0, 1.2, -1.1).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
          rightTriggerObj.rotation.y = yaw;
        } else {
          rightTriggerObj.position.copy(playerPos)
            .add(new THREE.Vector3(0.8, 1.2, -1.5).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ")));
          rightTriggerObj.rotation.y = yaw;
        }
        if (rightTriggerType === "senku" && rightSpecialActive) {
          rightTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = true;
          });
        } else if (rightTriggerType === "senku") {
          rightTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = false;
          });
        }
      }

      // 玉トリガー弾丸の移動・消去
      for (let i = 0; i < bullets.length; i++) {
        const bullet = bullets[i];
        if (!bullet.alive) continue;
        bullet.mesh.position.add(bullet.velocity);
        // メテオラ爆発判定
        if (bullet.type === "meteorora") {
          // 地面に着弾したら爆発
          if (bullet.mesh.position.y < 0.5) {
            // 爆発エフェクト生成
            const explosion = new THREE.Mesh(
              new THREE.SphereGeometry(2.2, 24, 24),
              new THREE.MeshPhysicalMaterial({
                color: 0xffee33,
                emissive: 0xffee33,
                emissiveIntensity: 2.5,
                transparent: true,
                opacity: 0.7,
                roughness: 0.25,
                metalness: 0.2
              })
            );
            explosion.position.copy(bullet.mesh.position);
            scene.add(explosion);
            explosions.push({ mesh: explosion, time: 0 });
            scene.remove(bullet.mesh);
            bullet.alive = false;
            continue;
          }
        }
        // 地面より下 or 遠くに行ったら消す
        if (bullet.mesh.position.y < 0.5 ||
            bullet.mesh.position.distanceTo(playerPos) > 120) {
          scene.remove(bullet.mesh);
          bullet.alive = false;
        }
      }

      // メテオラ爆発エフェクトの消去（0.5秒で消える）
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].time += 1 / 60;
        if (explosions[i].time > 0.5) {
          scene.remove(explosions[i].mesh);
          explosions.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = false;
          });
        }
      }

      // 玉トリガー弾丸の移動・消去
      for (let i = 0; i < bullets.length; i++) {
        const bullet = bullets[i];
        if (!bullet.alive) continue;
        bullet.mesh.position.add(bullet.velocity);
        // メテオラ爆発判定
        if (bullet.type === "meteorora") {
          // 地面に着弾したら爆発
          if (bullet.mesh.position.y < 0.5) {
            // 爆発エフェクト生成
            const explosion = new THREE.Mesh(
              new THREE.SphereGeometry(2.2, 24, 24),
              new THREE.MeshPhysicalMaterial({
                color: 0xffee33,
                emissive: 0xffee33,
                emissiveIntensity: 2.5,
                transparent: true,
                opacity: 0.7,
                roughness: 0.25,
                metalness: 0.2
              })
            );
            explosion.position.copy(bullet.mesh.position);
            scene.add(explosion);
            explosions.push({ mesh: explosion, time: 0 });
            scene.remove(bullet.mesh);
            bullet.alive = false;
            continue;
          }
        }
        // 地面より下 or 遠くに行ったら消す
        if (bullet.mesh.position.y < 0.5 ||
            bullet.mesh.position.distanceTo(playerPos) > 120) {
          scene.remove(bullet.mesh);
          bullet.alive = false;
        }
      }

      // メテオラ爆発エフェクトの消去（0.5秒で消える）
      for (let i = explosions.length - 1; i >= 0; i--) {
        explosions[i].time += 1 / 60;
        if (explosions[i].time > 0.5) {
          scene.remove(explosions[i].mesh);
          explosions.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
