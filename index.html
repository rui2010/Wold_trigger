<html>
  <head>
    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #myCanvas { display: block; background: #222; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #fff; font-size: 16px;
        background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 6px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="info">WASDで移動・マウスドラッグで視点回転・クリックでマウスキャプチャ</div>
    <canvas id="myCanvas"></canvas>
    <script>
      window.addEventListener("DOMContentLoaded", init);
      function init() {
        // レンダラーを作成
        const canvasElement = document.querySelector('#myCanvas');
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          canvas: canvasElement,
        });

        // サイズ指定
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成（FPS視点）
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        // プレイヤーの仮想位置と速度
        const playerPos = new THREE.Vector3(0, 2, 5);
        let playerVel = new THREE.Vector3(0, 0, 0);
        let isOnGround = false;
        const playerRadius = 1.2; // プレイヤーの当たり判定半径
        const playerHeight = 3.8; // プレイヤーの高さ
        camera.position.copy(playerPos);
        let yaw = 0;
        let pitch = -0.18; // 少し下向き

        // 地面（緑色）
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x66cc66 });
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // ライト
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 10);
        scene.add(light);

        // 建物を赤色で広めに配置＋影を赤寄りに
        const buildings = [];
        for (let i = -2; i <= 2; i++) {
          for (let j = -2; j <= 2; j++) {
            if (i === 0 && j === 0) continue;
            const h = 10;
            const buildingGeometry = new THREE.BoxGeometry(4, h, 4);
            // 赤色＋影を赤寄りに
            const buildingMaterial = new THREE.MeshPhongMaterial({
              color: 0xff0000,
              emissive: 0x660000,
              emissiveIntensity: 0.35
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(i * 14, h / 2, j * 14);
            scene.add(building);
            buildings.push({ mesh: building, height: h, x: i * 14, z: j * 14, size: 2 });
          }
        }

        // FPS移動用の変数
        const move = { forward: false, backward: false, left: false, right: false };
        let speed = 0.1;

        // 重力・ジャンプ設定
        const gravity = -0.45;
        const jumpVel = 0.18;
        let wantJump = false;

        // キーボードイベント
        window.addEventListener('keydown', (e) => {
          if (e.code === 'KeyW') move.forward = true;
          if (e.code === 'KeyS') move.backward = true;
          if (e.code === 'KeyA') move.left = true;
          if (e.code === 'KeyD') move.right = true;
          if (e.code === 'Space') wantJump = true;
        });
        window.addEventListener('keyup', (e) => {
          if (e.code === 'KeyW') move.forward = false;
          if (e.code === 'KeyS') move.backward = false;
          if (e.code === 'KeyA') move.left = false;
          if (e.code === 'KeyD') move.right = false;
        });

        // 設定画面UI追加
        const settingsDiv = document.createElement('div');
        settingsDiv.style.position = 'absolute';
        settingsDiv.style.top = '10px';
        settingsDiv.style.right = '10px';
        settingsDiv.style.background = 'rgba(255,255,255,0.95)';
        settingsDiv.style.padding = '16px';
        settingsDiv.style.borderRadius = '8px';
        settingsDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        settingsDiv.style.zIndex = 200;
        settingsDiv.style.fontSize = '14px';
        settingsDiv.style.minWidth = '180px';
        settingsDiv.innerHTML = `
          <b>設定</b><br>
          <label>
              <span>視点</span>
              <select id="viewModeSelect">
                  <option value="fps">一人称視点（FPS）</option>
                  <option value="tps">三人称視点（TPS）</option>
              </select>
          </label>
          <br><br>
          <label>
              <span>移動速度</span>
              <input id="speedRange" type="range" min="0.05" max="0.5" step="0.01" value="0.1">
              <span id="speedValue">0.10</span>
          </label>
          <br><br>
          <button id="closeSettings">閉じる</button>
        `;
        // 設定画面の開閉ボタン（左上）
        const openBtn = document.createElement('button');
        openBtn.textContent = '設定';
        openBtn.style.position = 'absolute';
        openBtn.style.top = '10px';
        openBtn.style.left = '10px';
        openBtn.style.zIndex = 201;
        openBtn.style.padding = '8px 16px';
        openBtn.style.fontSize = '14px';
        openBtn.style.borderRadius = '8px';
        openBtn.style.border = 'none';
        openBtn.style.background = '#eee';
        openBtn.style.cursor = 'pointer';
        document.body.appendChild(openBtn);
        document.body.appendChild(settingsDiv);
        settingsDiv.style.display = 'none';
        openBtn.addEventListener('click', () => {
          settingsDiv.style.display = '';
          openBtn.style.display = 'none';
        });
        settingsDiv.querySelector('#closeSettings').addEventListener('click', () => {
          settingsDiv.style.display = 'none';
          openBtn.style.display = '';
        });

        // 視点切り替え
        let viewMode = 'fps';
        const viewModeSelect = settingsDiv.querySelector('#viewModeSelect');
        viewModeSelect.value = viewMode;
        viewModeSelect.addEventListener('change', () => {
          viewMode = viewModeSelect.value;
          if (viewMode === 'fps') {
            camera.position.set(playerPos.x, playerPos.y, playerPos.z);
          }
        });

        // 移動速度設定
        const speedRange = settingsDiv.querySelector('#speedRange');
        const speedValue = settingsDiv.querySelector('#speedValue');
        speedRange.addEventListener('input', () => {
          speed = parseFloat(speedRange.value);
          speedValue.textContent = speed.toFixed(2);
        });

        // PointerLockでマウスキャプチャ
        canvasElement.addEventListener('click', () => {
          if (viewMode === 'fps') {
            canvasElement.requestPointerLock();
          }
        });

        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === canvasElement) {
            document.addEventListener('mousemove', onMouseMove, false);
          } else {
            document.removeEventListener('mousemove', onMouseMove, false);
          }
        });

        function onMouseMove(e) {
          const sensitivity = 0.002;
          yaw -= e.movementX * sensitivity;
          pitch -= e.movementY * sensitivity;
          pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        }

        // ミニキャラクター表示用
        const miniCanvas = document.createElement('canvas');
        miniCanvas.width = 120;
        miniCanvas.height = 120;
        miniCanvas.style.position = 'absolute';
        miniCanvas.style.top = '10px';
        miniCanvas.style.right = '10px';
        miniCanvas.style.zIndex = 300;
        miniCanvas.style.background = 'rgba(255,255,255,0.7)';
        miniCanvas.style.borderRadius = '8px';
        miniCanvas.style.display = 'none';
        document.body.appendChild(miniCanvas);

        const miniRenderer = new THREE.WebGLRenderer({ canvas: miniCanvas, alpha: true, antialias: true });
        miniRenderer.setClearColor(0x000000, 0);
        miniRenderer.setSize(120, 120);
        const miniScene = new THREE.Scene();
        const miniCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
        miniCamera.position.set(0, 5, 10);
        miniCamera.lookAt(0, 2, 0);
        const miniCharGeometry = new THREE.BoxGeometry(2, 4, 2);
        const miniCharMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const miniChar = new THREE.Mesh(miniCharGeometry, miniCharMaterial);
        miniChar.position.y = 2;
        miniScene.add(miniChar);
        const miniLight = new THREE.DirectionalLight(0xffffff, 1);
        miniLight.position.set(5, 10, 5);
        miniScene.add(miniLight);

        // 簡易コリジョン判定関数
        function checkCollision(pos) {
          // 地面
          if (pos.y < playerHeight / 2) {
            pos.y = playerHeight / 2;
            playerVel.y = 0;
            isOnGround = true;
          } else {
            isOnGround = false;
          }
          // 建物
          for (const b of buildings) {
            // 水平方向XZでAABB判定
            const minX = b.x - 2, maxX = b.x + 2;
            const minZ = b.z - 2, maxZ = b.z + 2;
            const minY = 0, maxY = b.height;
            // プレイヤーの足元位置
            const px = pos.x, py = pos.y - playerHeight / 2, pz = pos.z;
            // プレイヤーのAABB
            const pMinX = px - playerRadius, pMaxX = px + playerRadius;
            const pMinZ = pz - playerRadius, pMaxZ = pz + playerRadius;
            const pMinY = py, pMaxY = py + playerHeight;

            // 3D AABB衝突
            if (
              pMaxX > minX && pMinX < maxX &&
              pMaxZ > minZ && pMinZ < maxZ &&
              pMaxY > minY && pMinY < maxY
            ) {
              // Y方向（上下）でめり込み補正
              if (py < maxY && py > minY && playerVel.y < 0) {
                pos.y = maxY + playerHeight / 2;
                playerVel.y = 0;
                isOnGround = true;
              } else {
                // XZ方向で押し戻す
                const dx1 = Math.abs(pMaxX - minX);
                const dx2 = Math.abs(pMinX - maxX);
                const dz1 = Math.abs(pMaxZ - minZ);
                const dz2 = Math.abs(pMinZ - maxZ);
                const minDist = Math.min(dx1, dx2, dz1, dz2);
                if (minDist === dx1) pos.x = minX - playerRadius;
                else if (minDist === dx2) pos.x = maxX + playerRadius;
                else if (minDist === dz1) pos.z = minZ - playerRadius;
                else if (minDist === dz2) pos.z = maxZ + playerRadius;
              }
            }
          }
        }

        // アニメーションループ
        function animate() {
          requestAnimationFrame(animate);

          // 視点ごとにカメラ位置・向きを制御
          if (viewMode === 'fps') {
            camera.position.copy(playerPos);
            camera.rotation.order = "YXZ";
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = 0;
          } else if (viewMode === 'tps') {
            const tpsDistance = 18;
            const tpsPitch = pitch;
            const tpsYaw = yaw;
            const offset = new THREE.Vector3(
              Math.sin(tpsYaw) * Math.cos(tpsPitch) * tpsDistance,
              Math.sin(tpsPitch) * tpsDistance + 4,
              Math.cos(tpsYaw) * Math.cos(tpsPitch) * tpsDistance
            );
            camera.position.copy(playerPos.clone().add(offset));
            camera.lookAt(playerPos);
          }

          // 移動処理（プレイヤー位置を動かす）
          let direction = new THREE.Vector3();
          if (move.forward) direction.z += 1;
          if (move.backward) direction.z -= 1;
          if (move.left) direction.x -= 1;
          if (move.right) direction.x += 1;
          direction.normalize();

          // FPS移動ベクトル
          let moveVector = new THREE.Vector3();
          if (direction.length() > 0) {
            if (viewMode === 'fps') {
              const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
              const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
              moveVector = forward.multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)).normalize();
            } else {
              moveVector = new THREE.Vector3(direction.x, 0, direction.z);
              moveVector.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
            }
          }

          // ジャンプ
          if (wantJump && isOnGround) {
            playerVel.y = jumpVel;
            isOnGround = false;
          }
          wantJump = false;

          // 重力
          playerVel.y += gravity * 0.5;

          // 移動速度
          playerVel.x = moveVector.x * speed;
          playerVel.z = moveVector.z * speed;

          // 位置更新
          playerPos.add(playerVel);

          // コリジョン
          checkCollision(playerPos);

          // カメラをプレイヤー位置に
          if (viewMode === 'fps') {
            camera.position.copy(playerPos);
          }

          // ミニキャラ表示
          if (moveVector.length() > 0 || Math.abs(playerVel.y) > 0.01) {
            miniCanvas.style.display = '';
          } else {
            miniCanvas.style.display = 'none';
          }

          renderer.render(scene, camera);

          miniChar.rotation.y = -yaw;
          miniRenderer.render(miniScene, miniCamera);
        }
        animate();
      }
    </script>
  </body>
</html>