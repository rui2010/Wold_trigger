<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ワールドトリガー 市街地Aテスト</title>
  <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #fff; font-size: 16px;
      background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 6px;
      z-index: 10;
    }
    #leftTriggerUI, #rightTriggerUI {
      position: fixed;
      bottom: 20px;
      width: 220px;
      height: 80px;
      background: rgba(40,40,60,0.5);
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: space-around;
      z-index: 20;
      pointer-events: none;
    }
    #leftTriggerUI { left: 20px; }
    #rightTriggerUI { right: 20px; flex-direction: row-reverse; }
    .trigger-slot {
      width: 44px; height: 44px;
      background: rgba(180,180,200,0.18);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      margin: 0 2px;
      font-size: 0.9em;
      color: #fff;
      border: 2px solid transparent;
      transition: border 0.2s;
    }
    .trigger-selected {
      border: 2px solid #66ccff;
      background: rgba(80,160,255,0.25);
    }
  </style>
</head>
<body>
  <div id="info">
    WASD:移動 / Shift:しゃがみ / Space:ジャンプ / Ctrl+W:走り<br>
    左クリック:左手トリガー / 右クリック:右手トリガー<br>
    Q:左トリガー変更 / E:右トリガー変更 / F:左特殊 / G:右特殊
  </div>
  <div id="leftTriggerUI"></div>
  <div id="rightTriggerUI"></div>
  <canvas id="gameCanvas"></canvas>
  <script>
    // --- THREE.jsセットアップ ---
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x222222);
    function resizeRenderer() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, true);
      canvas.width = w; canvas.height = h;
    }
    resizeRenderer();
    window.addEventListener('resize', resizeRenderer);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    // --- 市街地Aマップ ---
    // 7x7グリッド、中央広場、道路、建物
    const mapSize = 7, blockSize = 8, roadWidth = 2;
    const buildingHeight = [8, 10, 12, 14];
    for (let gx = 0; gx < mapSize; gx++) {
      for (let gz = 0; gz < mapSize; gz++) {
        if (gx >= 2 && gx <= 4 && gz >= 2 && gz <= 4) continue;
        if (gx === 3 || gz === 3 || gx === 2 || gx === 4 || gz === 2 || gz === 4) continue;
        if (Math.random() < 0.13) continue;
        const h = buildingHeight[Math.floor(Math.random() * buildingHeight.length)];
        const building = new THREE.Mesh(
          new THREE.BoxGeometry(blockSize, h, blockSize),
          new THREE.MeshPhongMaterial({ color: 0xcccccc, emissive: 0x444444, emissiveIntensity: 0.25 })
        );
        building.position.set((gx - 3) * (blockSize + 2), h / 2, (gz - 3) * (blockSize + 2));
        scene.add(building);
      }
    }
    // 地面
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshPhongMaterial({ color: 0x66cc66 })
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);
    // 道路
    const roadMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
    for (let gx = 2; gx <= 4; gx++) {
      const road = new THREE.Mesh(
        new THREE.BoxGeometry(roadWidth, 0.11, mapSize * (blockSize + 2)),
        roadMat
      );
      road.position.set((gx - 3) * (blockSize + 2), 0.06, 0);
      scene.add(road);
    }
    for (let gz = 2; gz <= 4; gz++) {
      const road = new THREE.Mesh(
        new THREE.BoxGeometry(mapSize * (blockSize + 2), 0.11, roadWidth),
        roadMat
      );
      road.position.set(0, 0.06, (gz - 3) * (blockSize + 2));
      scene.add(road);
    }
    // 広場
    const plaza = new THREE.Mesh(
      new THREE.BoxGeometry((roadWidth + 1) * (blockSize + 2), 0.12, (roadWidth + 1) * (blockSize + 2)),
      new THREE.MeshPhongMaterial({ color: 0xddddcc })
    );
    plaza.position.set(0, 0.07, 0);
    scene.add(plaza);

    // --- ライト ---
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);

    // --- プレイヤー ---
    let playerPos = new THREE.Vector3(0, 2, 0);
    let playerVel = new THREE.Vector3(0, 0, 0);
    let isOnGround = false, isCrouching = false, isRunning = false;
    let yaw = 0, pitch = 0;
    let standHeight = 3.8, crouchHeight = 2.0, playerHeight = standHeight;

    // --- トリガー（武器）モデル ---
    function createTriggerModel(type) {
      if (type === "asteroid") {
        // アステロイド：六角形のクリスタル弾（漫画風に透明感とエッジ）
        const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0x99ff66,
          roughness: 0.25,
          metalness: 0.2,
          transmission: 0.7,
          transparent: true,
          opacity: 0.7,
          clearcoat: 0.6,
          clearcoatRoughness: 0.1
        });
        return new THREE.Mesh(geo, mat);
      }
      if (type === "hound") {
        // ハウンド：小さめの球体弾（漫画風に光沢）
        const geo = new THREE.SphereGeometry(0.28, 18, 18);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xffcc66,
          roughness: 0.15,
          metalness: 0.3,
          transmission: 0.5,
          transparent: true,
          opacity: 0.8,
          clearcoat: 0.5
        });
        return new THREE.Mesh(geo, mat);
      }
      if (type === "viper") {
        // バイパー：六角形のクリスタル弾（色違い、漫画風）
        const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xffcc33,
          roughness: 0.2,
          metalness: 0.3,
          transmission: 0.7,
          transparent: true,
          opacity: 0.7,
          clearcoat: 0.7
        });
        return new THREE.Mesh(geo, mat);
      }
      if (type === "meteorora") {
        // メテオラ：赤い球体（爆発エフェクト風）
        const geo = new THREE.SphereGeometry(0.38, 18, 18);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0xff3333,
          roughness: 0.3,
          metalness: 0.1,
          transmission: 0.4,
          transparent: true,
          opacity: 0.7,
          clearcoat: 0.4
        });
        return new THREE.Mesh(geo, mat);
      }
      if (type === "shield") {
        // シールド：漫画風の六角形バリア（透明感＋エッジ）
        const geo = new THREE.CylinderGeometry(0.5, 0.5, 0.08, 6);
        const mat = new THREE.MeshPhysicalMaterial({
          color: 0x99ccff,
          roughness: 0.1,
          metalness: 0.1,
          transmission: 0.9,
          transparent: true,
          opacity: 0.5,
          clearcoat: 0.8,
          clearcoatRoughness: 0.05,
          ior: 1.4
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        return mesh;
      }
      if (type === "kogetsu") {
        // 弧月：漫画風の刀（黒い柄＋銀色の湾曲刃）
        const group = new THREE.Group();
        // 刃（湾曲）
        const bladeCurve = new THREE.TorusGeometry(0.38, 0.04, 12, 40, Math.PI * 0.7);
        const bladeMat = new THREE.MeshPhysicalMaterial({
          color: 0xe0e0e0,
          metalness: 0.8,
          roughness: 0.2,
          clearcoat: 0.7
        });
        const blade = new THREE.Mesh(bladeCurve, bladeMat);
        blade.rotation.z = Math.PI / 2;
        blade.position.y = 0.35;
        group.add(blade);
        // 柄
        const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.18, 12), new THREE.MeshPhongMaterial({ color: 0x222222 }));
        grip.position.y = -0.25;
        group.add(grip);
        return group;
      }
      if (type === "senku") {
        // 旋空弧月：弧月＋青いエフェクト（漫画風）
        const group = new THREE.Group();
        // 刃（湾曲）
        const bladeCurve = new THREE.TorusGeometry(0.38, 0.04, 12, 40, Math.PI * 0.7);
        const bladeMat = new THREE.MeshPhysicalMaterial({
          color: 0xe0e0e0,
          metalness: 0.8,
          roughness: 0.2,
          clearcoat: 0.7
        });
        const blade = new THREE.Mesh(bladeCurve, bladeMat);
        blade.rotation.z = Math.PI / 2;
        blade.position.y = 0.35;
        group.add(blade);
        // 柄
        const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.18, 12), new THREE.MeshPhongMaterial({ color: 0x222222 }));
        grip.position.y = -0.25;
        group.add(grip);
        // 旋空エフェクト
        const effect = new THREE.Mesh(
          new THREE.TorusGeometry(0.55, 0.02, 8, 32, Math.PI * 1.2),
          new THREE.MeshPhysicalMaterial({
            color: 0x3399ff,
            transparent: true,
            opacity: 0.5,
            transmission: 0.8,
            roughness: 0.1,
            metalness: 0.2
          })
        );
        effect.position.y = 0.45;
        effect.rotation.z = Math.PI / 2;
        group.add(effect);
        return group;
      }
      // デフォルト
      return new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshPhongMaterial({ color: 0x999999 }));
    }

    // --- トリガーセット ---
    const TRIGGERS = ["asteroid", "hound", "viper", "meteorora", "shield", "kogetsu", "senku"];
    let leftTriggerSet = ["asteroid", "hound", "viper", "meteorora"];
    let rightTriggerSet = ["shield", "kogetsu", "senku", "asteroid"];
    let leftTriggerIndex = 0, rightTriggerIndex = 0;
    let leftTriggerType = leftTriggerSet[leftTriggerIndex], rightTriggerType = rightTriggerSet[rightTriggerIndex];

    // --- トリガーUI描画 ---
    function updateTriggerUI() {
      const leftUI = document.getElementById('leftTriggerUI');
      const rightUI = document.getElementById('rightTriggerUI');
      leftUI.innerHTML = '';
      rightUI.innerHTML = '';
      for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.className = 'trigger-slot' + (i === leftTriggerIndex ? ' trigger-selected' : '');
        slot.textContent = getTriggerName(leftTriggerSet[i]);
        leftUI.appendChild(slot);
      }
      for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.className = 'trigger-slot' + (i === rightTriggerIndex ? ' trigger-selected' : '');
        slot.textContent = getTriggerName(rightTriggerSet[i]);
        rightUI.appendChild(slot);
      }
    }
    function getTriggerName(type) {
      switch(type) {
        case "asteroid": return "アステロイド";
        case "hound": return "ハウンド";
        case "viper": return "バイパー";
        case "meteorora": return "メテオラ";
        case "shield": return "シールド";
        case "kogetsu": return "弧月";
        case "senku": return "旋空弧月";
        default: return type;
      }
    }
    updateTriggerUI();

    // --- 入力 ---
    const move = { forward: false, backward: false, left: false, right: false };
    window.addEventListener('keydown', (e) => {
      if (e.code === 'KeyW') move.forward = true;
      if (e.code === 'KeyS') move.backward = true;
      if (e.code === 'KeyA') move.left = true;
      if (e.code === 'KeyD') move.right = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = true;
      if (e.code === 'Space') wantJump = true;
      if (e.code === 'ControlLeft' || e.code === 'ControlRight') isRunning = true;
      if (e.code === 'KeyQ') {
        leftTriggerIndex = (leftTriggerIndex + 1) % leftTriggerSet.length;
        leftTriggerType = leftTriggerSet[leftTriggerIndex];
        updateTriggerUI();
      }
      if (e.code === 'KeyE') {
        rightTriggerIndex = (rightTriggerIndex + 1) % rightTriggerSet.length;
        rightTriggerType = rightTriggerSet[rightTriggerIndex];
        updateTriggerUI();
      }
      // F:左特殊, G:右特殊（例:旋空弧月のエフェクトON/OFF）
      if (e.code === 'KeyF') leftSpecialActive = !leftSpecialActive;
      if (e.code === 'KeyG') rightSpecialActive = !rightSpecialActive;
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'KeyW') move.forward = false;
      if (e.code === 'KeyS') move.backward = false;
      if (e.code === 'KeyA') move.left = false;
      if (e.code === 'KeyD') move.right = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = false;
      if (e.code === 'ControlLeft' || e.code === 'ControlRight') isRunning = false;
    });

    // --- 視点 ---
    canvas.addEventListener('click', () => { canvas.requestPointerLock(); });
    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === canvas) {
        document.addEventListener('mousemove', onMouseMove, false);
      } else {
        document.removeEventListener('mousemove', onMouseMove, false);
      }
    });
    function onMouseMove(e) {
      const sensitivity = 0.002;
      yaw -= e.movementX * sensitivity;
      pitch -= e.movementY * sensitivity;
      pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
    }

    // --- ジャンプ ---
    let wantJump = false;

    // --- トリガー発動 ---
    let leftTriggerObj = null, rightTriggerObj = null;
    let leftSpecialActive = false, rightSpecialActive = false;
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0 && !leftTriggerObj) {
        leftTriggerObj = createTriggerModel(leftTriggerType);
        scene.add(leftTriggerObj);
      }
      if (e.button === 2 && !rightTriggerObj) {
        rightTriggerObj = createTriggerModel(rightTriggerType);
        scene.add(rightTriggerObj);
      }
    });
    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 0 && leftTriggerObj) {
        scene.remove(leftTriggerObj);
        leftTriggerObj = null;
      }
      if (e.button === 2 && rightTriggerObj) {
        scene.remove(rightTriggerObj);
        rightTriggerObj = null;
      }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // --- ゲームループ ---
    function animate() {
      requestAnimationFrame(animate);

      // 移動速度
      let speed = isRunning ? 0.22 : 0.13;
      if (isCrouching) {
        playerHeight = crouchHeight;
      } else {
        playerHeight = standHeight;
      }

      // 移動
      let direction = new THREE.Vector3();
      if (move.forward) direction.z -= 1; // Wで前進
      if (move.backward) direction.z += 1; // Sで後退
      if (move.left) direction.x -= 1;    // Aで左
      if (move.right) direction.x += 1;   // Dで右
      direction.normalize();
      let moveVector = new THREE.Vector3();
      if (direction.length() > 0) {
        // カメラの向きに合わせて移動
        const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
        const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
        moveVector = forward.multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)).normalize();
      }
      playerVel.x = moveVector.x * speed;
      playerVel.z = moveVector.z * speed;

      // ジャンプ
      if (wantJump && isOnGround) {
        playerVel.y = 0.18;
        isOnGround = false;
      }
      wantJump = false;

      // 重力
      playerVel.y += -0.45 * 0.5;

      // 位置更新
      playerPos.add(playerVel);

      // 地面判定
      if (playerPos.y < 1.0) {
        playerPos.y = 1.0;
        playerVel.y = 0;
        isOnGround = true;
      } else {
        isOnGround = false;
      }

      // カメラ
      camera.position.copy(playerPos);
      camera.position.y += playerHeight - 1.8;
      camera.rotation.order = "YXZ";
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
      camera.rotation.z = 0;

      // トリガーの手元表示（左は左側、右は右側）
      if (leftTriggerObj) {
        leftTriggerObj.position.copy(camera.position);
        leftTriggerObj.position.add(new THREE.Vector3(-0.8, -1.2, -1.5).applyEuler(camera.rotation));
        leftTriggerObj.rotation.copy(camera.rotation);
        if (leftTriggerType === "senku" && leftSpecialActive) {
          leftTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = true;
          });
        } else if (leftTriggerType === "senku") {
          leftTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = false;
          });
        }
      }
      if (rightTriggerObj) {
        rightTriggerObj.position.copy(camera.position);
        rightTriggerObj.position.add(new THREE.Vector3(0.8, -1.2, -1.5).applyEuler(camera.rotation));
        rightTriggerObj.rotation.copy(camera.rotation);
        if (rightTriggerType === "senku" && rightSpecialActive) {
          rightTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = true;
          });
        } else if (rightTriggerType === "senku") {
          rightTriggerObj.children.forEach(obj => {
            if (obj.geometry && obj.geometry.type === "CylinderGeometry") obj.visible = false;
          });
        }
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
        // --- 武器タイプ
        // 右手・左手で独立
        let rightWeaponType = getCurrentRightTrigger();
        let leftWeaponType = getCurrentLeftTrigger();

        // 右手・左手の発射状態
        let rightIsCharging = false, leftIsCharging = false;
        let rightChargeObj = null, leftChargeObj = null;
        let rightChargeReady = false, leftChargeReady = false;
        let rightRaygustMesh = null, leftRaygustMesh = null;
        let rightScorpionMesh = null, leftScorpionMesh = null;
        let rightGrasshopperMesh = null, leftGrasshopperMesh = null;

        // 右クリック/左クリックで右手/左手発動
        canvas.addEventListener('mousedown', (e) => {
          // 0:左クリック→右手, 2:右クリック→左手
          if (e.button === 0 && !rightIsCharging && !rightChargeObj) {
            rightWeaponType = getCurrentRightTrigger();
            rightIsCharging = true;
            rightChargeReady = false;
            // --- 武器モデルをワールドトリガー風に ---
            if (rightWeaponType === "asteroid") {
              // アステロイド：六角形の浮遊弾
              const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
              const mat = new THREE.MeshPhongMaterial({ color: 0x99ff66, emissive: 0x336633, emissiveIntensity: 0.5, flatShading: true });
              rightChargeObj = new THREE.Mesh(geo, mat);
              scene.add(rightChargeObj);
            } else if (rightWeaponType === "raygust") {
              // レイガスト：盾＋グリップ
              const group = new THREE.Group();
              const shield = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.1, 0.12), new THREE.MeshPhongMaterial({ color: 0xccccff, emissive: 0x333366, emissiveIntensity: 0.7 }));
              shield.position.x = 0.18;
              group.add(shield);
              const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.5, 12), new THREE.MeshPhongMaterial({ color: 0x888899 }));
              grip.rotation.z = Math.PI/2;
              grip.position.x = -0.18;
              group.add(grip);
              rightRaygustMesh = group;
              scene.add(rightRaygustMesh);
            } else if (rightWeaponType === "scorpion") {
              // スコーピオン：赤い三角刃
              const group = new THREE.Group();
              const blade = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.7, 3), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0x660000, emissiveIntensity: 0.7 }));
              blade.position.y = 0.35;
              blade.rotation.x = Math.PI;
              group.add(blade);
              rightScorpionMesh = group;
              scene.add(rightScorpionMesh);
            } else if (rightWeaponType === "egret") {
              // イーグレット：細長い銃身＋スコープ
              const group = new THREE.Group();
              const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.2, 12), new THREE.MeshPhongMaterial({ color: 0x333333 }));
              barrel.rotation.x = Math.PI/2;
              group.add(barrel);
              const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.25, 12), new THREE.MeshPhongMaterial({ color: 0x666666 }));
              scope.position.z = 0.35;
              scope.rotation.x = Math.PI/2;
              group.add(scope);
              rightChargeObj = group;
              scene.add(rightChargeObj);
            } else if (rightWeaponType === "viper") {
              // バイパー：六角形の浮遊弾（色違い）
              const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
              const mat = new THREE.MeshPhongMaterial({ color: 0xffcc33, emissive: 0x664400, emissiveIntensity: 0.5, flatShading: true });
              rightChargeObj = new THREE.Mesh(geo, mat);
              scene.add(rightChargeObj);
            } else if (rightWeaponType === "grasshopper") {
              // グラスホッパー：緑色のパネル
              const geo = new THREE.BoxGeometry(0.6, 0.1, 0.6);
              const mat = new THREE.MeshPhongMaterial({ color: 0x33ff66, emissive: 0x006633, emissiveIntensity: 0.7 });
              rightGrasshopperMesh = new THREE.Mesh(geo, mat);
              scene.add(rightGrasshopperMesh);
            }
          }
          if (e.button === 2 && !leftIsCharging && !leftChargeObj) {
            leftWeaponType = getCurrentLeftTrigger();
            leftIsCharging = true;
            leftChargeReady = false;
            // --- 武器モデルをワールドトリガー風に ---
            if (leftWeaponType === "asteroid") {
              const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
              const mat = new THREE.MeshPhongMaterial({ color: 0x99ff66, emissive: 0x336633, emissiveIntensity: 0.5, flatShading: true });
              leftChargeObj = new THREE.Mesh(geo, mat);
              scene.add(leftChargeObj);
            } else if (leftWeaponType === "raygust") {
              const group = new THREE.Group();
              const shield = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.1, 0.12), new THREE.MeshPhongMaterial({ color: 0xccccff, emissive: 0x333366, emissiveIntensity: 0.7 }));
              shield.position.x = -0.18;
              group.add(shield);
              const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.5, 12), new THREE.MeshPhongMaterial({ color: 0x888899 }));
              grip.rotation.z = Math.PI/2;
              grip.position.x = 0.18;
              group.add(grip);
              leftRaygustMesh = group;
              scene.add(leftRaygustMesh);
            } else if (leftWeaponType === "scorpion") {
              const group = new THREE.Group();
              const blade = new THREE.Mesh(new THREE.ConeGeometry(0.09, 0.7, 3), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0x660000, emissiveIntensity: 0.7 }));
              blade.position.y = 0.35;
              blade.rotation.x = Math.PI;
              group.add(blade);
              leftScorpionMesh = group;
              scene.add(leftScorpionMesh);
            } else if (leftWeaponType === "egret") {
              const group = new THREE.Group();
              const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.2, 12), new THREE.MeshPhongMaterial({ color: 0x333333 }));
              barrel.rotation.x = Math.PI/2;
              group.add(barrel);
              const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.25, 12), new THREE.MeshPhongMaterial({ color: 0x666666 }));
              scope.position.z = 0.35;
              scope.rotation.x = Math.PI/2;
              group.add(scope);
              leftChargeObj = group;
              scene.add(leftChargeObj);
            } else if (leftWeaponType === "viper") {
              const geo = new THREE.CylinderGeometry(0.35, 0.35, 0.7, 6);
              const mat = new THREE.MeshPhongMaterial({ color: 0xffcc33, emissive: 0x664400, emissiveIntensity: 0.5, flatShading: true });
              leftChargeObj = new THREE.Mesh(geo, mat);
              scene.add(leftChargeObj);
            } else if (leftWeaponType === "grasshopper") {
              const geo = new THREE.BoxGeometry(0.6, 0.1, 0.6);
              const mat = new THREE.MeshPhongMaterial({ color: 0x33ff66, emissive: 0x006633, emissiveIntensity: 0.7 });
              leftGrasshopperMesh = new THREE.Mesh(geo, mat);
              scene.add(leftGrasshopperMesh);
            }
          }
        });

        // 右手（左クリック）/左手（右クリック）発動
        canvas.addEventListener('mouseup', (e) => {
          if (e.button === 0 && rightIsCharging) {
            if (!rightChargeReady) { rightChargeReady = true; return; }
            // 右手発動
            if (rightWeaponType === "asteroid" && rightChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: rightChargeObj,
                velocity: dir.multiplyScalar(0.7),
                alive: true
              });
              rightChargeObj = null;
              rightIsCharging = false;
              rightChargeReady = false;
            } else if (rightWeaponType === "raygust" && rightRaygustMesh) {
              rightIsCharging = false;
              setTimeout(() => {
                if (rightRaygustMesh) {
                  scene.remove(rightRaygustMesh);
                  rightRaygustMesh = null;
                }
              }, 500);
            } else if (rightWeaponType === "scorpion" && rightScorpionMesh) {
              rightIsCharging = false;
              setTimeout(() => {
                if (rightScorpionMesh) {
                  scene.remove(rightScorpionMesh);
                  rightScorpionMesh = null;
                }
              }, 350);
            } else if (rightWeaponType === "egret" && rightChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: rightChargeObj,
                velocity: dir.multiplyScalar(2.0),
                alive: true
              });
              rightChargeObj = null;
              rightIsCharging = false;
            } else if (rightWeaponType === "viper" && rightChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: rightChargeObj,
                velocity: dir.multiplyScalar(0.7),
                alive: true,
                viper: true,
                viperStep: 0
              });
              rightChargeObj = null;
              rightIsCharging = false;
            } else if (rightWeaponType === "grasshopper" && rightGrasshopperMesh) {
              rightIsCharging = false;
              scene.remove(rightGrasshopperMesh);
              rightGrasshopperMesh = null;
              playerVel.y = 0.38;
            }
          }
          if (e.button === 2 && leftIsCharging) {
            if (!leftChargeReady) { leftChargeReady = true; return; }
            // 左手発動
            if (leftWeaponType === "asteroid" && leftChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: leftChargeObj,
                velocity: dir.multiplyScalar(0.7),
                alive: true
              });
              leftChargeObj = null;
              leftIsCharging = false;
              leftChargeReady = false;
            } else if (leftWeaponType === "raygust" && leftRaygustMesh) {
              leftIsCharging = false;
              setTimeout(() => {
                if (leftRaygustMesh) {
                  scene.remove(leftRaygustMesh);
                  leftRaygustMesh = null;
                }
              }, 500);
            } else if (leftWeaponType === "scorpion" && leftScorpionMesh) {
              leftIsCharging = false;
              setTimeout(() => {
                if (leftScorpionMesh) {
                  scene.remove(leftScorpionMesh);
                  leftScorpionMesh = null;
                }
              }, 350);
            } else if (leftWeaponType === "egret" && leftChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: leftChargeObj,
                velocity: dir.multiplyScalar(2.0),
                alive: true
              });
              leftChargeObj = null;
              leftIsCharging = false;
            } else if (leftWeaponType === "viper" && leftChargeObj) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: leftChargeObj,
                velocity: dir.multiplyScalar(0.7),
                alive: true,
                viper: true,
                viperStep: 0
              });
              leftChargeObj = null;
              leftIsCharging = false;
            } else if (leftWeaponType === "grasshopper" && leftGrasshopperMesh) {
              leftIsCharging = false;
              scene.remove(leftGrasshopperMesh);
              leftGrasshopperMesh = null;
              playerVel.y = 0.38;
            }
          }
        });

        // 右クリックのコンテキストメニュー抑制
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // --- 入力 ---
        const move = { forward: false, backward: false, left: false, right: false };
        let speed = 0.13;
        let gravity = -0.45;
        let jumpVel = 0.18;
        let wantJump = false;
        window.addEventListener('keydown', (e) => {
          if (e.code === 'KeyW') move.forward = true;
          if (e.code === 'KeyS') move.backward = true;
          if (e.code === 'KeyA') move.left = true;
          if (e.code === 'KeyD') move.right = true;
          if (e.code === 'Space') wantJump = true;
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = true;
        });
        window.addEventListener('keyup', (e) => {
          if (e.code === 'KeyW') move.forward = false;
          if (e.code === 'KeyS') move.backward = false;
          if (e.code === 'KeyA') move.left = false;
          if (e.code === 'KeyD') move.right = false;
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = false;
        });
        canvas.addEventListener('click', () => {
          if (viewMode === 'fps') canvas.requestPointerLock();
        });
        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === canvas) {
            document.addEventListener('mousemove', onMouseMove, false);
          } else {
            document.removeEventListener('mousemove', onMouseMove, false);
          }
        });
        function onMouseMove(e) {
          const sensitivity = 0.002;
          yaw -= e.movementX * sensitivity;
          pitch -= e.movementY * sensitivity;
          pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        }

        // --- ゲームループ ---
        function animate() {
          requestAnimationFrame(animate);

          // キャラ位置
          player.position.set(playerPos.x, playerPos.y, playerPos.z);

          // カメラ
          if (viewMode === 'fps') {
            camera.position.set(playerPos.x, playerPos.y + 6, playerPos.z + 24);
            camera.lookAt(playerPos.x, playerPos.y + 2, playerPos.z);
            camera.rotation.order = "YXZ";
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = 0;
          } else {
            // TPS未実装
          }

          // 移動
          let direction = new THREE.Vector3();
          if (move.forward) direction.z -= 1; // Wで前進
          if (move.backward) direction.z += 1; // Sで後退
          if (move.left) direction.x -= 1;
          if (move.right) direction.x += 1;
          direction.normalize();
          let moveVector = new THREE.Vector3();
          if (direction.length() > 0) {
            // カメラの向きに合わせて移動
            const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
            const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
            moveVector = forward.multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)).normalize();
          }
          // ジャンプ
          if (wantJump && isOnGround) {
            playerVel.y = jumpVel;
            isOnGround = false;
          }
          wantJump = false;
          // 重力
          playerVel.y += gravity * 0.5;
          // 移動速度
          playerVel.x = moveVector.x * speed;
          playerVel.z = moveVector.z * speed;
          // 位置更新
          playerPos.add(playerVel);
          // 地面
          if (playerPos.y < 1.0) {
            playerPos.y = 1.0;
            playerVel.y = 0;
            isOnGround = true;
          } else {
            isOnGround = false;
          }

          // 武器の手元表示
          if (viewMode === 'fps') {
            // 右手（左クリック）
            if (rightWeaponType === "asteroid" && rightChargeObj) {
              rightChargeObj.visible = true;
              rightChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(0.6, -1.2, -1.5);
              offset.applyEuler(camera.rotation);
              rightChargeObj.position.add(offset);
              rightChargeObj.rotation.copy(camera.rotation);
            } else if (rightWeaponType === "raygust" && rightRaygustMesh) {
              rightRaygustMesh.visible = true;
              rightRaygustMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(0.8, -0.2, -1.0);
              offset.applyEuler(camera.rotation);
              rightRaygustMesh.position.add(offset);
              rightRaygustMesh.rotation.copy(camera.rotation);
            } else if (rightWeaponType === "scorpion" && rightScorpionMesh) {
              rightScorpionMesh.visible = true;
              rightScorpionMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(0.7, -0.3, -1.0);
              offset.applyEuler(camera.rotation);
              rightScorpionMesh.position.add(offset);
              rightScorpionMesh.rotation.copy(camera.rotation);
            } else if (rightWeaponType === "egret" && rightChargeObj) {
              rightChargeObj.visible = true;
              rightChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(0.6, -0.7, -1.7);
              offset.applyEuler(camera.rotation);
              rightChargeObj.position.add(offset);
              rightChargeObj.rotation.copy(camera.rotation);
            } else if (rightWeaponType === "viper" && rightChargeObj) {
              rightChargeObj.visible = true;
              rightChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(0.6, -1.2, -1.5);
              offset.applyEuler(camera.rotation);
              rightChargeObj.position.add(offset);
              rightChargeObj.rotation.copy(camera.rotation);
            } else if (rightWeaponType === "grasshopper" && rightGrasshopperMesh) {
              rightGrasshopperMesh.visible = true;
              rightGrasshopperMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(0.6, -1.0, -1.2);
              offset.applyEuler(camera.rotation);
              rightGrasshopperMesh.position.add(offset);
              rightGrasshopperMesh.rotation.copy(camera.rotation);
            }
            // 左手（右クリック）
            if (leftWeaponType === "asteroid" && leftChargeObj) {
              leftChargeObj.visible = true;
              leftChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.6, -1.2, -1.5);
              offset.applyEuler(camera.rotation);
              leftChargeObj.position.add(offset);
              leftChargeObj.rotation.copy(camera.rotation);
            } else if (leftWeaponType === "raygust" && leftRaygustMesh) {
              leftRaygustMesh.visible = true;
              leftRaygustMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.8, -0.2, -1.0);
              offset.applyEuler(camera.rotation);
              leftRaygustMesh.position.add(offset);
              leftRaygustMesh.rotation.copy(camera.rotation);
            } else if (leftWeaponType === "scorpion" && leftScorpionMesh) {
              leftScorpionMesh.visible = true;
              leftScorpionMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.7, -0.3, -1.0);
              offset.applyEuler(camera.rotation);
              leftScorpionMesh.position.add(offset);
              leftScorpionMesh.rotation.copy(camera.rotation);
            } else if (leftWeaponType === "egret" && leftChargeObj) {
              leftChargeObj.visible = true;
              leftChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.6, -0.7, -1.7);
              offset.applyEuler(camera.rotation);
              leftChargeObj.position.add(offset);
              leftChargeObj.rotation.copy(camera.rotation);
            } else if (leftWeaponType === "viper" && leftChargeObj) {
              leftChargeObj.visible = true;
              leftChargeObj.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.6, -1.2, -1.5);
              offset.applyEuler(camera.rotation);
              leftChargeObj.position.add(offset);
              leftChargeObj.rotation.copy(camera.rotation);
            } else if (leftWeaponType === "grasshopper" && leftGrasshopperMesh) {
              leftGrasshopperMesh.visible = true;
              leftGrasshopperMesh.position.copy(camera.position);
              const offset = new THREE.Vector3(-0.6, -1.0, -1.2);
              offset.applyEuler(camera.rotation);
              leftGrasshopperMesh.position.add(offset);
              leftGrasshopperMesh.rotation.copy(camera.rotation);
            }
          }

          // アステロイド弾丸の移動
          for (const bullet of asteroidBullets) {
            if (!bullet.alive) continue;
            if (bullet.viper) {
              // バイパーは曲射
              bullet.mesh.position.add(bullet.velocity);
              bullet.viperStep = (bullet.viperStep || 0) + 1;
              // 途中でカーブ
              if (bullet.viperStep === 15) {
                bullet.velocity.x += (Math.random() - 0.5) * 0.7;
                bullet.velocity.y += (Math.random() - 0.5) * 0.2;
              }
            } else {
              bullet.mesh.position.add(bullet.velocity);
            }
            if (bullet.mesh.position.y < 0) {
              scene.remove(bullet.mesh);
              bullet.alive = false;
            }
          }

          // 手元のアステロイド
          if (viewMode === 'fps' && chargeAsteroid) {
            chargeAsteroid.visible = true;
            chargeAsteroid.position.copy(camera.position);
            const offset = new THREE.Vector3(0.0, -1.2, -1.5);
            offset.applyEuler(camera.rotation);
            chargeAsteroid.position.add(offset);
            chargeAsteroid.rotation.copy(camera.rotation);
          }

          // レーダー描画
          if (radarVisible) {
            radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
            // レーダー円
            radarCtx.save();
            radarCtx.globalAlpha = 0.7;
            radarCtx.beginPath();
            radarCtx.arc(90, 90, 85, 0, Math.PI * 2);
            radarCtx.fillStyle = "#222";
            radarCtx.fill();
            radarCtx.restore();
            // プレイヤー中心
            radarCtx.beginPath();
            radarCtx.arc(90, 90, 6, 0, Math.PI * 2);
            radarCtx.fillStyle = "#00bfff";
            radarCtx.fill();
            // 建物
            for (let i = -2; i <= 2; i++) {
              for (let j = -2; j <= 2; j++) {
                if (i === 0 && j === 0) continue;
                const bx = i * 14, bz = j * 14;
                const dx = bx - playerPos.x;
                const dz = bz - playerPos.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if (dist > 60) continue;
                const angle = Math.atan2(dx, dz) - yaw;
                const r = dist * 2;
                const rx = 90 + Math.sin(angle) * r;
                const ry = 90 + Math.cos(angle) * r;
                radarCtx.beginPath();
                radarCtx.arc(rx, ry, 8, 0, Math.PI * 2);
                radarCtx.fillStyle = "#ff4444";
                radarCtx.fill();
              }
            }
            // 弾（アステロイド等）
            for (const bullet of asteroidBullets) {
              if (!bullet.alive) continue;
              const dx = bullet.mesh.position.x - playerPos.x;
              const dz = bullet.mesh.position.z - playerPos.z;
              const dist = Math.sqrt(dx*dx + dz*dz);
              if (dist > 60) continue;
              const angle = Math.atan2(dx, dz) - yaw;
              const r = dist * 2;
              const rx = 90 + Math.sin(angle) * r;
              const ry = 90 + Math.cos(angle) * r;
              radarCtx.beginPath();
              radarCtx.arc(rx, ry, 4, 0, Math.PI * 2);
              radarCtx.fillStyle = "#99ff66";
              radarCtx.fill();
            }
          }

          renderer.render(scene, camera);
        }
        animate();
      }
    </script>
  </body>
</html>
