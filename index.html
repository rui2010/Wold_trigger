<html>
  <head>
    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      #myCanvas { display: block; background: #222; }
      #info {
        position: absolute; top: 10px; left: 10px; color: #fff; font-size: 16px;
        background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 6px;
        z-index: 10;
      }
      #charamake {
        position: absolute; left: 0; top: 0; width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.85); z-index: 1000; display: flex; align-items: center; justify-content: center;
      }
      #charamake-inner {
        background: #fff; border-radius: 12px; padding: 32px 40px; min-width: 340px;
        box-shadow: 0 4px 24px rgba(0,0,0,0.4); text-align: center;
      }
      #charamake label { display: block; margin: 16px 0 8px; }
      #charamake input[type="color"] { width: 48px; height: 32px; border: none; }
      #charamake select { font-size: 16px; }
      #charamake-preview { margin: 16px auto; width: 120px; height: 160px; background: #eee; border-radius: 8px; }
      #charamake button { margin-top: 24px; font-size: 18px; padding: 8px 32px; border-radius: 8px; border: none; background: #66cc66; color: #fff; cursor: pointer; }
    </style>
  </head>
  <body>
    <div id="info">WASDで移動・スペースでジャンプ・Shiftでしゃがみ・マウスドラッグで視点回転・クリックでマウスキャプチャ</div>
    <canvas id="myCanvas"></canvas>
    <!-- キャラメイク画面 -->
    <div id="charamake">
      <div id="charamake-inner">
        <h2>キャラクター作成</h2>
        <label>髪の色 <input type="color" id="hairColor" value="#222222"></label>
        <label>髪型
          <select id="hairType">
            <option value="short">ショート</option>
            <option value="long">ロング</option>
            <option value="spiky">スパイキー</option>
          </select>
        </label>
        <label>顔
          <select id="faceType">
            <option value="normal">ノーマル</option>
            <option value="smile">スマイル</option>
            <option value="angry">怒り</option>
          </select>
        </label>
        <label>体の色 <input type="color" id="bodyColor" value="#ff0000"></label>
        <label>素材
          <select id="materialType">
            <option value="phong">つやあり</option>
            <option value="lambert">つやなし</option>
            <option value="basic">マット</option>
          </select>
        </label>
        <label>足
          <select id="legType">
            <option value="normal">ノーマル</option>
            <option value="long">ロング</option>
            <option value="short">ショート</option>
          </select>
        </label>
        <label>右手
          <select id="handType">
            <option value="box">ボックス</option>
            <option value="sphere">ボール</option>
            <option value="blade">ブレード</option>
          </select>
        </label>
        <div id="charamake-preview"></div>
        <button id="charamake-start">ゲームスタート</button>
      </div>
    </div>
    <script>
      // キャラメイク用プレビュー
      let charaParams = {
        color: "#ff0000",
        material: "phong",
        hand: "box",
        hairColor: "#222222",
        hairType: "short",
        faceType: "normal",
        legType: "normal"
      };
      let previewRenderer, previewScene, previewCamera, previewBody, previewHand;
      function setupCharamakePreview() {
        const previewDiv = document.getElementById('charamake-preview');
        previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        previewRenderer.setClearColor(0x000000, 0);
        previewRenderer.setSize(120, 160);
        previewDiv.innerHTML = '';
        previewDiv.appendChild(previewRenderer.domElement);
        previewScene = new THREE.Scene();
        previewCamera = new THREE.PerspectiveCamera(40, 120/160, 0.1, 100);
        previewCamera.position.set(0, 4, 16);
        previewCamera.lookAt(0, 4, 0);
        // ライト
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 10);
        previewScene.add(light);
        // キャラ本体（人型＋髪＋顔＋足）
        previewBody = createHumanMeshPreview(
          getMaterial(charaParams.material, charaParams.color),
          charaParams
        );
        previewBody.position.y = 0;
        previewScene.add(previewBody);
        // 右手
        previewHand = createHandMesh(charaParams.hand, charaParams.color, charaParams.material);
        previewHand.position.set(0.8, 2.2, 0.5);
        previewScene.add(previewHand);
        previewRender();
      }
      function previewRender() {
        if (!previewRenderer) return;
        previewRenderer.render(previewScene, previewCamera);
      }
      function updatePreview() {
        previewScene.remove(previewBody);
        previewBody = createHumanMeshPreview(
          getMaterial(charaParams.material, charaParams.color),
          charaParams
        );
        previewBody.position.y = 0;
        previewScene.add(previewBody);
        previewScene.remove(previewHand);
        previewHand = createHandMesh(charaParams.hand, charaParams.color, charaParams.material);
        previewHand.position.set(0.8, 2.2, 0.5);
        previewScene.add(previewHand);
        previewRender();
      }
      // キャラメイク用人型プレビュー
      function createHumanMeshPreview(material, params) {
        const group = new THREE.Group();
        // 胴体
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.7), material);
        body.position.y = 2.1;
        group.add(body);
        // 頭
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), material);
        head.position.y = 3.5;
        group.add(head);
        // 髪
        const hairMat = new THREE.MeshPhongMaterial({ color: params.hairColor });
        if (params.hairType === "short") {
          const hair = new THREE.Mesh(new THREE.SphereGeometry(0.62, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.7), hairMat);
          hair.position.y = 3.9;
          group.add(hair);
        } else if (params.hairType === "long") {
          const hair = new THREE.Mesh(new THREE.SphereGeometry(0.62, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.1), hairMat);
          hair.position.y = 3.7;
          group.add(hair);
        } else if (params.hairType === "spiky") {
          for (let i = 0; i < 5; i++) {
            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.7, 8), hairMat);
            spike.position.set(Math.sin(i * 1.25) * 0.4, 4.1, Math.cos(i * 1.25) * 0.4);
            spike.rotation.x = Math.PI / 2.5;
            group.add(spike);
          }
        }
        // 顔（目・口）
        if (params.faceType === "normal" || params.faceType === "smile" || params.faceType === "angry") {
          const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
          const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
          leftEye.position.set(-0.18, 3.55, 0.57);
          group.add(leftEye);
          const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
          rightEye.position.set(0.18, 3.55, 0.57);
          group.add(rightEye);
          // 口
          if (params.faceType === "smile") {
            const mouth = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.03, 8, 16, Math.PI), new THREE.MeshBasicMaterial({ color: 0x222222 }));
            mouth.position.set(0, 3.33, 0.58);
            mouth.rotation.x = Math.PI / 2;
            group.add(mouth);
          } else if (params.faceType === "angry") {
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.04, 0.04), new THREE.MeshBasicMaterial({ color: 0x222222 }));
            mouth.position.set(0, 3.32, 0.58);
            group.add(mouth);
          }
        }
        // 両腕
        const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 1.3, 12), material);
        rightArm.position.set(0.85, 2.5, 0);
        rightArm.rotation.z = Math.PI / 10;
        group.add(rightArm);
        const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 1.3, 12), material);
        leftArm.position.set(-0.85, 2.5, 0);
        leftArm.rotation.z = -Math.PI / 10;
        group.add(leftArm);
        // 足
        let legLen = 1.5;
        if (params.legType === "long") legLen = 2.1;
        if (params.legType === "short") legLen = 1.0;
        const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, legLen, 12), material);
        rightLeg.position.set(0.38, legLen / 2, 0);
        group.add(rightLeg);
        const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, legLen, 12), material);
        leftLeg.position.set(-0.38, legLen / 2, 0);
        group.add(leftLeg);
        return group;
      }
      function getMaterial(type, color) {
        if (type === "phong") return new THREE.MeshPhongMaterial({ color });
        if (type === "lambert") return new THREE.MeshLambertMaterial({ color });
        if (type === "basic") return new THREE.MeshBasicMaterial({ color });
        return new THREE.MeshPhongMaterial({ color });
      }
      function createHandMesh(type, color, materialType) {
        const mat = getMaterial(materialType, color);
        if (type === "box") {
          return new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 0.7), mat);
        } else if (type === "sphere") {
          return new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), mat);
        } else if (type === "blade") {
          const group = new THREE.Group();
          const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.7, 12), mat);
          grip.position.y = -0.25;
          group.add(grip);
          const blade = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.3), new THREE.MeshPhongMaterial({ color: 0xccccff }));
          blade.position.y = 0.7;
          group.add(blade);
          return group;
        }
        return new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 0.7), mat);
      }
      setupCharamakePreview();
      document.getElementById('bodyColor').addEventListener('input', e => {
        charaParams.color = e.target.value;
        updatePreview();
      });
      document.getElementById('materialType').addEventListener('change', e => {
        charaParams.material = e.target.value;
        updatePreview();
      });
      document.getElementById('handType').addEventListener('change', e => {
        charaParams.hand = e.target.value;
        updatePreview();
      });
      document.getElementById('hairColor').addEventListener('input', e => {
        charaParams.hairColor = e.target.value;
        updatePreview();
      });
      document.getElementById('hairType').addEventListener('change', e => {
        charaParams.hairType = e.target.value;
        updatePreview();
      });
      document.getElementById('faceType').addEventListener('change', e => {
        charaParams.faceType = e.target.value;
        updatePreview();
      });
      document.getElementById('legType').addEventListener('change', e => {
        charaParams.legType = e.target.value;
        updatePreview();
      });

      // --- ゲーム本体 ---
      let gameStarted = false;
      document.getElementById('charamake-start').addEventListener('click', () => {
        document.getElementById('charamake').style.display = 'none';
        gameStarted = true;
        startGame();
      });

      function startGame() {
        // レンダラーを作成
        const canvasElement = document.querySelector('#myCanvas');
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          canvas: canvasElement,
        });

        // サイズ指定
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成（FPS視点）
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        // プレイヤーの仮想位置と速度
        const playerPos = new THREE.Vector3(0, 2, 5);
        let playerVel = new THREE.Vector3(0, 0, 0);
        let isOnGround = false;
        let isCrouching = false;
        const playerRadius = 1.2;
        let playerHeight = 3.8;
        let standHeight = 3.8;
        let crouchHeight = 2.0;
        camera.position.copy(playerPos);
        let yaw = 0;
        let pitch = -0.18;

        // 地面（緑色）
        const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x66cc66 });
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // ライト
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 10);
        scene.add(light);

        // 建物を赤色で広めに配置＋影を赤寄りに
        const buildings = [];
        for (let i = -2; i <= 2; i++) {
          for (let j = -2; j <= 2; j++) {
            if (i === 0 && j === 0) continue;
            const h = 10;
            const buildingGeometry = new THREE.BoxGeometry(4, h, 4);
            const buildingMaterial = new THREE.MeshPhongMaterial({
              color: 0xff0000,
              emissive: 0x660000,
              emissiveIntensity: 0.35
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(i * 14, h / 2, j * 14);
            scene.add(building);
            buildings.push({ mesh: building, height: h, x: i * 14, z: j * 14, size: 2 });
          }
        }

        // --- ワールドトリガーのアステロイド（浮遊する立方体）を追加 ---
        const asteroids = [];
        for (let i = 0; i < 8; i++) {
          const geo = new THREE.BoxGeometry(2, 2, 2);
          const mat = new THREE.MeshPhongMaterial({ color: 0xcccccc, emissive: 0x333366, emissiveIntensity: 0.5 });
          const asteroid = new THREE.Mesh(geo, mat);
          asteroid.position.set(
            Math.random() * 60 - 30,
            6 + Math.random() * 10,
            Math.random() * 60 - 30
          );
          scene.add(asteroid);
          asteroids.push(asteroid);
        }

        // --- キャラクター本体・右手 ---
        // キャラ本体（人型：胴体・頭・両手・両足）
        function createHumanMesh(material, params) {
          const group = new THREE.Group();
          // 胴体
          const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.7), material);
          body.position.y = 2.1;
          group.add(body);
          // 頭
          const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), material);
          head.position.y = 3.5;
          group.add(head);
          // 髪
          const hairMat = new THREE.MeshPhongMaterial({ color: params.hairColor });
          if (params.hairType === "short") {
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.62, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.7), hairMat);
            hair.position.y = 3.9;
            group.add(hair);
          } else if (params.hairType === "long") {
            const hair = new THREE.Mesh(new THREE.SphereGeometry(0.62, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.1), hairMat);
            hair.position.y = 3.7;
            group.add(hair);
          } else if (params.hairType === "spiky") {
            for (let i = 0; i < 5; i++) {
              const spike = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.7, 8), hairMat);
              spike.position.set(Math.sin(i * 1.25) * 0.4, 4.1, Math.cos(i * 1.25) * 0.4);
              spike.rotation.x = Math.PI / 2.5;
              group.add(spike);
            }
          }
          // 顔（目・口）
          if (params.faceType === "normal" || params.faceType === "smile" || params.faceType === "angry") {
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
            leftEye.position.set(-0.18, 3.55, 0.57);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
            rightEye.position.set(0.18, 3.55, 0.57);
            group.add(rightEye);
            // 口
            if (params.faceType === "smile") {
              const mouth = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.03, 8, 16, Math.PI), new THREE.MeshBasicMaterial({ color: 0x222222 }));
              mouth.position.set(0, 3.33, 0.58);
              mouth.rotation.x = Math.PI / 2;
              group.add(mouth);
            } else if (params.faceType === "angry") {
              const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.04, 0.04), new THREE.MeshBasicMaterial({ color: 0x222222 }));
              mouth.position.set(0, 3.32, 0.58);
              group.add(mouth);
            }
          }
          // 両腕
          const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 1.3, 12), material);
          rightArm.position.set(0.85, 2.5, 0);
          rightArm.rotation.z = Math.PI / 10;
          group.add(rightArm);
          const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 1.3, 12), material);
          leftArm.position.set(-0.85, 2.5, 0);
          leftArm.rotation.z = -Math.PI / 10;
          group.add(leftArm);
          // 足
          let legLen = 1.5;
          if (params.legType === "long") legLen = 2.1;
          if (params.legType === "short") legLen = 1.0;
          const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, legLen, 12), material);
          rightLeg.position.set(0.38, legLen / 2, 0);
          group.add(rightLeg);
          const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, legLen, 12), material);
          leftLeg.position.set(-0.38, legLen / 2, 0);
          group.add(leftLeg);
          return group;
        }

        const playerMeshMaterial = getMaterial(charaParams.material, charaParams.color);
        const playerMesh = createHumanMesh(playerMeshMaterial, charaParams);
        playerMesh.position.set(playerPos.x, playerPos.y, playerPos.z);
        playerMesh.visible = false;
        scene.add(playerMesh);

        // 右手（人の手モデル）
        function createRightHandMesh(material) {
          const group = new THREE.Group();
          // 手のひら
          const palm = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.18, 0.7), material);
          palm.position.set(0, 0, 0);
          group.add(palm);
          // 親指
          const thumb = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.38, 8), material);
          thumb.position.set(-0.23, 0.07, 0.18);
          thumb.rotation.z = Math.PI / 2.5;
          group.add(thumb);
          // 4本指
          for (let i = 0; i < 4; i++) {
            const finger = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.48, 8), material);
            finger.position.set(-0.15 + i * 0.1, 0.13, 0.32);
            finger.rotation.x = Math.PI / 2.1;
            group.add(finger);
          }
          group.scale.set(1.1, 1.1, 1.1);
          return group;
        }
        let rightHandMesh = createRightHandMesh(playerMeshMaterial);
        rightHandMesh.visible = false;
        scene.add(rightHandMesh);

        // --- アステロイド弾丸 ---
        const asteroidBullets = [];
        let canShoot = true;
        let loadedAsteroid = null;
        let isCharging = false;
        let chargeAsteroid = null;
        let chargeStartTime = 0;
        let splitAsteroids = [];
        let isSplit = false;
        let isLineMode = false;

        // アステロイドを装填
        function loadAsteroid(color = 0xcccccc) {
          if (loadedAsteroid || isCharging) return;
          const geo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
          const mat = new THREE.MeshPhongMaterial({ color, emissive: 0x333366, emissiveIntensity: 0.5 });
          loadedAsteroid = new THREE.Mesh(geo, mat);
          scene.add(loadedAsteroid);
        }

        // マウス長押しで黄緑色アステロイド
        window.addEventListener('mousedown', (e) => {
          if (viewMode === 'fps' && !isCharging && canShoot) {
            isCharging = true;
            chargeStartTime = performance.now();
            // 黄緑色アステロイド
            const geo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
            const mat = new THREE.MeshPhongMaterial({ color: 0x99ff66, emissive: 0x336633, emissiveIntensity: 0.5 });
            chargeAsteroid = new THREE.Mesh(geo, mat);
            scene.add(chargeAsteroid);
          }
        });

        window.addEventListener('mouseup', (e) => {
          if (isCharging && !isSplit && !isLineMode) {
            // 通常弾として発射
            if (chargeAsteroid) {
              const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
              asteroidBullets.push({
                mesh: chargeAsteroid,
                velocity: dir.multiplyScalar(0.7),
                alive: true,
                isLine: false
              });
              chargeAsteroid = null;
              isCharging = false;
              canShoot = false;
              setTimeout(() => { canShoot = true; loadAsteroid(); }, 400);
            }
          } else if (isCharging && isSplit && !isLineMode) {
            // 分裂状態でクリック→線モード
            isLineMode = true;
            // 線用オブジェクト生成
            for (const s of splitAsteroids) {
              scene.remove(s.mesh);
            }
            splitAsteroids = [];
            // 線を作成
            const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
            const lineMat = new THREE.MeshBasicMaterial({ color: 0x99ff66 });
            const lineGeo = new THREE.CylinderGeometry(0.12, 0.12, 12, 8);
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.copy(camera.position);
            const offset = new THREE.Vector3(0.8, -0.3, -1.5).applyEuler(camera.rotation);
            line.position.add(offset).add(dir.clone().multiplyScalar(6));
            line.rotation.copy(camera.rotation);
            scene.add(line);
            asteroidBullets.push({
              mesh: line,
              velocity: dir.multiplyScalar(1.5),
              alive: true,
              isLine: true
            });
            isCharging = false;
            isSplit = false;
            isLineMode = false;
            chargeAsteroid = null;
            canShoot = false;
            setTimeout(() => { canShoot = true; loadAsteroid(); }, 400);
          }
        });

        // Fキーで分裂
        window.addEventListener('keydown', (e) => {
          // ...existing code...
          if (e.code === 'KeyR') loadAsteroid();
          if (e.code === 'KeyF' && isCharging && !isSplit && chargeAsteroid) {
            // 分裂
            isSplit = true;
            // 8方向に分裂
            splitAsteroids = [];
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 / 8) * i;
              const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
              const mat = new THREE.MeshPhongMaterial({ color: 0x99ff66, emissive: 0x336633, emissiveIntensity: 0.5 });
              const s = new THREE.Mesh(geo, mat);
              s.position.copy(chargeAsteroid.position);
              scene.add(s);
              splitAsteroids.push({
                mesh: s,
                velocity: new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).applyEuler(camera.rotation).normalize().multiplyScalar(0.7),
                alive: true,
                isLine: false
              });
            }
            scene.remove(chargeAsteroid);
            chargeAsteroid = null;
          }
        });

        // ゲーム開始時に1発装填
        loadAsteroid();

        // FPS移動用の変数
        const move = { forward: false, backward: false, left: false, right: false };
        let speed = 0.1;

        // 重力・ジャンプ設定
        const gravity = -0.45;
        const jumpVel = 0.18;
        let wantJump = false;

        // キーボードイベント
        window.addEventListener('keydown', (e) => {
          if (e.code === 'KeyW') move.forward = true;
          if (e.code === 'KeyS') move.backward = true;
          if (e.code === 'KeyA') move.left = true;
          if (e.code === 'KeyD') move.right = true;
          if (e.code === 'Space') wantJump = true;
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = true;
        });
        window.addEventListener('keyup', (e) => {
          if (e.code === 'KeyW') move.forward = false;
          if (e.code === 'KeyS') move.backward = false;
          if (e.code === 'KeyA') move.left = false;
          if (e.code === 'KeyD') move.right = false;
          if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') isCrouching = false;
        });

        // 設定画面UI追加
        const settingsDiv = document.createElement('div');
        settingsDiv.style.position = 'absolute';
        settingsDiv.style.top = '10px';
        settingsDiv.style.right = '10px';
        settingsDiv.style.background = 'rgba(255,255,255,0.95)';
        settingsDiv.style.padding = '16px';
        settingsDiv.style.borderRadius = '8px';
        settingsDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        settingsDiv.style.zIndex = 200;
        settingsDiv.style.fontSize = '14px';
        settingsDiv.style.minWidth = '180px';
        settingsDiv.innerHTML = `
          <b>設定</b><br>
          <label>
              <span>視点</span>
              <select id="viewModeSelect">
                  <option value="fps">一人称視点（FPS）</option>
                  <option value="tps">三人称視点（TPS）</option>
              </select>
          </label>
          <br><br>
          <label>
              <span>移動速度</span>
              <input id="speedRange" type="range" min="0.05" max="0.5" step="0.01" value="0.1">
              <span id="speedValue">0.10</span>
          </label>
          <br><br>
          <button id="closeSettings">閉じる</button>
        `;
        // 設定画面の開閉ボタン（左上）
        const openBtn = document.createElement('button');
        openBtn.textContent = '設定';
        openBtn.style.position = 'absolute';
        openBtn.style.top = '10px';
        openBtn.style.left = '10px';
        openBtn.style.zIndex = 201;
        openBtn.style.padding = '8px 16px';
        openBtn.style.fontSize = '14px';
        openBtn.style.borderRadius = '8px';
        openBtn.style.border = 'none';
        openBtn.style.background = '#eee';
        openBtn.style.cursor = 'pointer';
        document.body.appendChild(openBtn);
        document.body.appendChild(settingsDiv);
        settingsDiv.style.display = 'none';
        openBtn.addEventListener('click', () => {
          settingsDiv.style.display = '';
          openBtn.style.display = 'none';
        });
        settingsDiv.querySelector('#closeSettings').addEventListener('click', () => {
          settingsDiv.style.display = 'none';
          openBtn.style.display = '';
        });

        // 視点切り替え
        let viewMode = 'fps';
        const viewModeSelect = settingsDiv.querySelector('#viewModeSelect');
        viewModeSelect.value = viewMode;
        viewModeSelect.addEventListener('change', () => {
          viewMode = viewModeSelect.value;
          if (viewMode === 'fps') {
            camera.position.set(playerPos.x, playerPos.y, playerPos.z);
          }
        });

        // 移動速度設定
        const speedRange = settingsDiv.querySelector('#speedRange');
        const speedValue = settingsDiv.querySelector('#speedValue');
        speedRange.addEventListener('input', () => {
          speed = parseFloat(speedRange.value);
          speedValue.textContent = speed.toFixed(2);
        });

        // PointerLockでマウスキャプチャ
        canvasElement.addEventListener('click', () => {
          if (viewMode === 'fps') {
            canvasElement.requestPointerLock();
          }
        });

        document.addEventListener('pointerlockchange', () => {
          if (document.pointerLockElement === canvasElement) {
            document.addEventListener('mousemove', onMouseMove, false);
          } else {
            document.removeEventListener('mousemove', onMouseMove, false);
          }
        });

        function onMouseMove(e) {
          const sensitivity = 0.002;
          yaw -= e.movementX * sensitivity;
          pitch -= e.movementY * sensitivity;
          pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        }

        // ミニキャラクター表示用
        const miniCanvas = document.createElement('canvas');
        miniCanvas.width = 120;
        miniCanvas.height = 120;
        miniCanvas.style.position = 'absolute';
        miniCanvas.style.top = '10px';
        miniCanvas.style.right = '10px';
        miniCanvas.style.zIndex = 300;
        miniCanvas.style.background = 'rgba(255,255,255,0.7)';
        miniCanvas.style.borderRadius = '8px';
        miniCanvas.style.display = 'none';
        document.body.appendChild(miniCanvas);

        const miniRenderer = new THREE.WebGLRenderer({ canvas: miniCanvas, alpha: true, antialias: true });
        miniRenderer.setClearColor(0x000000, 0);
        miniRenderer.setSize(120, 120);
        const miniScene = new THREE.Scene();
        const miniCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
        miniCamera.position.set(0, 5, 10);
        miniCamera.lookAt(0, 2, 0);
        const miniCharGeometry = new THREE.BoxGeometry(2, 4, 2);
        const miniCharMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const miniChar = new THREE.Mesh(miniCharGeometry, miniCharMaterial);
        miniChar.position.y = 2;
        miniScene.add(miniChar);
        const miniLight = new THREE.DirectionalLight(0xffffff, 1);
        miniLight.position.set(5, 10, 5);
        miniScene.add(miniLight);

        // 簡易コリジョン判定関数
        function checkCollision(pos) {
          // 地面
          if (pos.y < playerHeight / 2) {
            pos.y = playerHeight / 2;
            playerVel.y = 0;
            isOnGround = true;
          } else {
            isOnGround = false;
          }
          // 建物
          for (const b of buildings) {
            const minX = b.x - 2, maxX = b.x + 2;
            const minZ = b.z - 2, maxZ = b.z + 2;
            const minY = 0, maxY = b.height;
            const px = pos.x, py = pos.y - playerHeight / 2, pz = pos.z;
            const pMinX = px - playerRadius, pMaxX = px + playerRadius;
            const pMinZ = pz - playerRadius, pMaxZ = pz + playerRadius;
            const pMinY = py, pMaxY = py + playerHeight;
            if (
              pMaxX > minX && pMinX < maxX &&
              pMaxZ > minZ && pMinZ < maxZ &&
              pMaxY > minY && pMinY < maxY
            ) {
              if (py < maxY && py > minY && playerVel.y < 0) {
                pos.y = maxY + playerHeight / 2;
                playerVel.y = 0;
                isOnGround = true;
              } else {
                const dx1 = Math.abs(pMaxX - minX);
                const dx2 = Math.abs(pMinX - maxX);
                const dz1 = Math.abs(pMaxZ - minZ);
                const dz2 = Math.abs(pMinZ - maxZ);
                const minDist = Math.min(dx1, dx2, dz1, dz2);
                if (minDist === dx1) pos.x = minX - playerRadius;
                else if (minDist === dx2) pos.x = maxX + playerRadius;
                else if (minDist === dz1) pos.z = minZ - playerRadius;
                else if (minDist === dz2) pos.z = maxZ + playerRadius;
              }
            }
          }
        }

        // アニメーションループ
        function animate() {
          requestAnimationFrame(animate);

          // アステロイドを回転
          for (const asteroid of asteroids) {
            asteroid.rotation.x += 0.01;
            asteroid.rotation.y += 0.013;
          }

          // しゃがみ処理
          if (isCrouching) {
            playerHeight = crouchHeight;
            playerMesh.scale.y = crouchHeight / standHeight;
          } else {
            playerHeight = standHeight;
            playerMesh.scale.y = 1;
          }

          // 視点ごとにカメラ位置・向きを制御
          if (viewMode === 'fps') {
            camera.position.copy(playerPos);
            camera.rotation.order = "YXZ";
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = 0;
          } else if (viewMode === 'tps') {
            // カメラをキャラの背後に固定
            const tpsDistance = 8;
            const tpsHeight = 3.5;
            // キャラの向き（進行方向 or yaw）で背後に配置
            const backYaw = yaw;
            const offset = new THREE.Vector3(
              Math.sin(backYaw) * tpsDistance,
              tpsHeight,
              Math.cos(backYaw) * tpsDistance
            );
            camera.position.copy(playerPos.clone().add(offset));
            camera.lookAt(playerPos.x, playerPos.y + 1.5, playerPos.z);
          }

          // 移動処理（プレイヤー位置を動かす）
          let direction = new THREE.Vector3();
          if (move.forward) direction.z -= 1;
          if (move.backward) direction.z += 1;
          if (move.left) direction.x -= 1;
          if (move.right) direction.x += 1;
          direction.normalize();

          // --- 三人称視点のときの移動方向修正 ---
          // Wで前進, Sで後退になるように修正
          let moveVector = new THREE.Vector3();
          if (direction.length() > 0) {
            if (viewMode === 'fps') {
              const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
              const right = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, yaw, 0, "YXZ"));
              moveVector = forward.multiplyScalar(direction.z).add(right.multiplyScalar(direction.x)).normalize();
            } else {
              moveVector = new THREE.Vector3(direction.x, 0, direction.z);
              moveVector.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
            }
          }

          // ジャンプ
          if (wantJump && isOnGround) {
            playerVel.y = jumpVel;
            isOnGround = false;
          }
          wantJump = false;

          // 重力
          playerVel.y += gravity * 0.5;

          // 移動速度
          playerVel.x = moveVector.x * speed;
          playerVel.z = moveVector.z * speed;

          // 位置更新
          playerPos.add(playerVel);

          // コリジョン
          checkCollision(playerPos);

          // カメラをプレイヤー位置に
          if (viewMode === 'fps') {
            camera.position.copy(playerPos);
          }

          // ミニキャラ表示
          if (moveVector.length() > 0 || Math.abs(playerVel.y) > 0.01) {
            miniCanvas.style.display = '';
          } else {
            miniCanvas.style.display = 'none';
          }

          // 三人称視点のときは自分キャラクターを表示し、位置を同期
          if (viewMode === 'tps') {
            playerMesh.visible = true;
            playerMesh.position.set(playerPos.x, playerPos.y, playerPos.z);
            rightHandMesh.visible = false;
          } else {
            playerMesh.visible = false;
            // 一人称視点のとき右手を表示
            rightHandMesh.visible = true;
            rightHandMesh.position.copy(camera.position);
            const handOffset = new THREE.Vector3(0.6, -0.6, -1.1);
            handOffset.applyEuler(camera.rotation);
            rightHandMesh.position.add(handOffset);
            rightHandMesh.rotation.copy(camera.rotation);
          }

          // アステロイド弾丸の移動
          for (const bullet of asteroidBullets) {
            if (!bullet.alive) continue;
            bullet.mesh.position.add(bullet.velocity);
            // 直線移動のみ（重力なし）
            // 地面に落ちたら消す
            if (bullet.mesh.position.y < 0) {
              scene.remove(bullet.mesh);
              bullet.alive = false;
            }
          }
          // 分裂アステロイドの移動
          for (const s of splitAsteroids) {
            if (!s.alive) continue;
            s.mesh.position.add(s.velocity);
            if (s.mesh.position.y < 0) {
              scene.remove(s.mesh);
              s.alive = false;
            }
          }

          // 装填中のアステロイド or チャージ中の黄緑アステロイド
          if (viewMode === 'fps') {
            if (loadedAsteroid) {
              loadedAsteroid.visible = true;
              loadedAsteroid.position.copy(camera.position);
              const offset = new THREE.Vector3(0.8, -0.3, -1.5);
              offset.applyEuler(camera.rotation);
              loadedAsteroid.position.add(offset);
              loadedAsteroid.rotation.copy(camera.rotation);
            } else if (chargeAsteroid) {
              chargeAsteroid.visible = true;
              chargeAsteroid.position.copy(camera.position);
              const offset = new THREE.Vector3(0.8, -0.3, -1.5);
              offset.applyEuler(camera.rotation);
              chargeAsteroid.position.add(offset);
              chargeAsteroid.rotation.copy(camera.rotation);
            }
          }
          // ...existing code...

          renderer.render(scene, camera);

          // ...existing code...
        }
        animate();
      }
    </script>
  </body>
</html>